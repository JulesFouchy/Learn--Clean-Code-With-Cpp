[{"title":"Alexandre M","type":0,"sectionRef":"#","url":"evaluation/Alexandre M/","content":"","keywords":""},{"title":"Tools (2 / 3 pts.)​","type":1,"pageTitle":"Alexandre M","url":"evaluation/Alexandre M/#tools-2--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson❌ Have a .clang-format file, and apply it to your codebase☁️ Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (7 / 12 pts.)​","type":1,"pageTitle":"Alexandre M","url":"evaluation/Alexandre M/#clean-code-7--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)☁️ Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ☁️ Hard to understand or misleading names (Naming)☁️ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2 / 3 pts.)​","type":1,"pageTitle":"Alexandre M","url":"evaluation/Alexandre M/#c-code-quality-2--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)☁️ Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: ☁️ Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)☁️ Forgetting #pragma once in your headers☁️ Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (3 / 4 pts.)​","type":1,"pageTitle":"Alexandre M","url":"evaluation/Alexandre M/#investment-3--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Adelie F","type":0,"sectionRef":"#","url":"evaluation/Adelie F/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Adelie F","url":"evaluation/Adelie F/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (8 / 12 pts.)​","type":1,"pageTitle":"Adelie F","url":"evaluation/Adelie F/#clean-code-8--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)❌ Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ❌ Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2 / 3 pts.)​","type":1,"pageTitle":"Adelie F","url":"evaluation/Adelie F/#c-code-quality-2--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Adelie F","url":"evaluation/Adelie F/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Baptiste J","type":0,"sectionRef":"#","url":"evaluation/Baptiste J/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Baptiste J","url":"evaluation/Baptiste J/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (10 / 12 pts.)​","type":1,"pageTitle":"Baptiste J","url":"evaluation/Baptiste J/#clean-code-10--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)🌞 Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)🌞 Use free functions as often as possible, and methods only when appropriate (Prefer free functions)🌞 Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)☁️ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2.5 / 3 pts.)​","type":1,"pageTitle":"Baptiste J","url":"evaluation/Baptiste J/#c-code-quality-25--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)☁️ Use destructors when things need to be destroyed at the end.🌞 Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (3 / 4 pts.)​","type":1,"pageTitle":"Baptiste J","url":"evaluation/Baptiste J/#investment-3--4-pts","content":"➕ What you should do: 🌞 Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Camille L","type":0,"sectionRef":"#","url":"evaluation/Camille L/","content":"","keywords":""},{"title":"Tools (1.5 / 3 pts.)​","type":1,"pageTitle":"Camille L","url":"evaluation/Camille L/#tools-15--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson❌ Have a .clang-format file, and apply it to your codebase☁️ Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (7.5 / 12 pts.)​","type":1,"pageTitle":"Camille L","url":"evaluation/Camille L/#clean-code-75--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)❌ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)❌ Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2 / 3 pts.)​","type":1,"pageTitle":"Camille L","url":"evaluation/Camille L/#c-code-quality-2--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.❌ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Camille L","url":"evaluation/Camille L/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Corentin P","type":0,"sectionRef":"#","url":"evaluation/Corentin P/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Corentin P","url":"evaluation/Corentin P/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (7.5 / 12 pts.)​","type":1,"pageTitle":"Corentin P","url":"evaluation/Corentin P/#clean-code-75--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ☁️ Hard to understand or misleading names (Naming)❌ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2 / 3 pts.)​","type":1,"pageTitle":"Corentin P","url":"evaluation/Corentin P/#c-code-quality-2--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)❌ Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (3 / 4 pts.)​","type":1,"pageTitle":"Corentin P","url":"evaluation/Corentin P/#investment-3--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class🌞 Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Elies B","type":0,"sectionRef":"#","url":"evaluation/Elies B/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Elies B","url":"evaluation/Elies B/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (7 / 12 pts.)​","type":1,"pageTitle":"Elies B","url":"evaluation/Elies B/#clean-code-7--12-pts","content":"➕ What you should do: ☁️ Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)🌞 Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)❌ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ❌ Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (1.5 / 3 pts.)​","type":1,"pageTitle":"Elies B","url":"evaluation/Elies B/#c-code-quality-15--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)☁️ Use destructors when things need to be destroyed at the end.❌ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)☁️ Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Elies B","url":"evaluation/Elies B/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Eliott D","type":0,"sectionRef":"#","url":"evaluation/Eliott D/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Eliott D","url":"evaluation/Eliott D/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (10 / 12 pts.)​","type":1,"pageTitle":"Eliott D","url":"evaluation/Eliott D/#clean-code-10--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)🌞 Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)🌞 Use free functions as often as possible, and methods only when appropriate (Prefer free functions)🌞 Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)☁️ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2.5 / 3 pts.)​","type":1,"pageTitle":"Eliott D","url":"evaluation/Eliott D/#c-code-quality-25--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)☁️ Use destructors when things need to be destroyed at the end.🌞 Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (3 / 4 pts.)​","type":1,"pageTitle":"Eliott D","url":"evaluation/Eliott D/#investment-3--4-pts","content":"➕ What you should do: 🌞 Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Coralie B","type":0,"sectionRef":"#","url":"evaluation/Coralie B/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Coralie B","url":"evaluation/Coralie B/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (6 / 12 pts.)​","type":1,"pageTitle":"Coralie B","url":"evaluation/Coralie B/#clean-code-6--12-pts","content":"➕ What you should do: ☁️ Write many small functions (Write small functions)☁️ Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)❌ Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)❌ Duplicated code (DRY: Don't repeat yourself)☁️ Overly complicated code☁️ Global variables "},{"title":"C++ Code Quality (2 / 3 pts.)​","type":1,"pageTitle":"Coralie B","url":"evaluation/Coralie B/#c-code-quality-2--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.❌ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (3 / 4 pts.)​","type":1,"pageTitle":"Coralie B","url":"evaluation/Coralie B/#investment-3--4-pts","content":"➕ What you should do: 🌞 Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Enzo B","type":0,"sectionRef":"#","url":"evaluation/Enzo B/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Enzo B","url":"evaluation/Enzo B/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (10 / 12 pts.)​","type":1,"pageTitle":"Enzo B","url":"evaluation/Enzo B/#clean-code-10--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)🌞 Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)🌞 Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ☁️ Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (1.5 / 3 pts.)​","type":1,"pageTitle":"Enzo B","url":"evaluation/Enzo B/#c-code-quality-15--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)❌ Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2.5 / 4 pts.)​","type":1,"pageTitle":"Enzo B","url":"evaluation/Enzo B/#investment-25--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Erwan T","type":0,"sectionRef":"#","url":"evaluation/Erwan T/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Erwan T","url":"evaluation/Erwan T/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (7.5 / 12 pts.)​","type":1,"pageTitle":"Erwan T","url":"evaluation/Erwan T/#clean-code-75--12-pts","content":"➕ What you should do: ☁️ Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2.5 / 3 pts.)​","type":1,"pageTitle":"Erwan T","url":"evaluation/Erwan T/#c-code-quality-25--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (3 / 4 pts.)​","type":1,"pageTitle":"Erwan T","url":"evaluation/Erwan T/#investment-3--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Florian T","type":0,"sectionRef":"#","url":"evaluation/Florian T/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Florian T","url":"evaluation/Florian T/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (8 / 12 pts.)​","type":1,"pageTitle":"Florian T","url":"evaluation/Florian T/#clean-code-8--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ❌ Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (1.5 / 3 pts.)​","type":1,"pageTitle":"Florian T","url":"evaluation/Florian T/#c-code-quality-15--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)❌ Use destructors when things need to be destroyed at the end.❌ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (3 / 4 pts.)​","type":1,"pageTitle":"Florian T","url":"evaluation/Florian T/#investment-3--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Enora C","type":0,"sectionRef":"#","url":"evaluation/Enora C/","content":"","keywords":""},{"title":"Tools (2.5 / 3 pts.)​","type":1,"pageTitle":"Enora C","url":"evaluation/Enora C/#tools-25--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: ❌ Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (6.5 / 12 pts.)​","type":1,"pageTitle":"Enora C","url":"evaluation/Enora C/#clean-code-65--12-pts","content":"➕ What you should do: ☁️ Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)❌ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)☁️ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (1.5 / 3 pts.)​","type":1,"pageTitle":"Enora C","url":"evaluation/Enora C/#c-code-quality-15--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)❌ Use destructors when things need to be destroyed at the end.❌ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Enora C","url":"evaluation/Enora C/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Guilhem D","type":0,"sectionRef":"#","url":"evaluation/Guilhem D/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Guilhem D","url":"evaluation/Guilhem D/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (11 / 12 pts.)​","type":1,"pageTitle":"Guilhem D","url":"evaluation/Guilhem D/#clean-code-11--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)🌞 Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)🌞 Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ☁️ Hard to understand or misleading names (Naming)☁️ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (3 / 3 pts.)​","type":1,"pageTitle":"Guilhem D","url":"evaluation/Guilhem D/#c-code-quality-3--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.🌞 Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Guilhem D","url":"evaluation/Guilhem D/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Heidi L","type":0,"sectionRef":"#","url":"evaluation/Heidi L/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Heidi L","url":"evaluation/Heidi L/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (7.5 / 12 pts.)​","type":1,"pageTitle":"Heidi L","url":"evaluation/Heidi L/#clean-code-75--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ☁️ Hard to understand or misleading names (Naming)❌ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2 / 3 pts.)​","type":1,"pageTitle":"Heidi L","url":"evaluation/Heidi L/#c-code-quality-2--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)❌ Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (3 / 4 pts.)​","type":1,"pageTitle":"Heidi L","url":"evaluation/Heidi L/#investment-3--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class🌞 Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Laura G","type":0,"sectionRef":"#","url":"evaluation/Laura G/","content":"","keywords":""},{"title":"Tools (1.5 / 3 pts.)​","type":1,"pageTitle":"Laura G","url":"evaluation/Laura G/#tools-15--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson❌ Have a .clang-format file, and apply it to your codebase❌ Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (7.5 / 12 pts.)​","type":1,"pageTitle":"Laura G","url":"evaluation/Laura G/#clean-code-75--12-pts","content":"➕ What you should do: ☁️ Write many small functions (Write small functions)☁️ Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)❌ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code☁️ Global variables "},{"title":"C++ Code Quality (2 / 3 pts.)​","type":1,"pageTitle":"Laura G","url":"evaluation/Laura G/#c-code-quality-2--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Laura G","url":"evaluation/Laura G/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Lea T","type":0,"sectionRef":"#","url":"evaluation/Lea T/","content":"","keywords":""},{"title":"Tools (2 / 3 pts.)​","type":1,"pageTitle":"Lea T","url":"evaluation/Lea T/#tools-2--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson☁️ Have a .clang-format file, and apply it to your codebase☁️ Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (7 / 12 pts.)​","type":1,"pageTitle":"Lea T","url":"evaluation/Lea T/#clean-code-7--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)☁️ Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)🌞 Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)❌ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (1.5 / 3 pts.)​","type":1,"pageTitle":"Lea T","url":"evaluation/Lea T/#c-code-quality-15--3-pts","content":"➕ What you should do: ❌ Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Lea T","url":"evaluation/Lea T/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Lena C","type":0,"sectionRef":"#","url":"evaluation/Lena C/","content":"","keywords":""},{"title":"Tools (2.5 / 3 pts.)​","type":1,"pageTitle":"Lena C","url":"evaluation/Lena C/#tools-25--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: ❌ Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (6.5 / 12 pts.)​","type":1,"pageTitle":"Lena C","url":"evaluation/Lena C/#clean-code-65--12-pts","content":"➕ What you should do: ☁️ Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)❌ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)☁️ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (1.5 / 3 pts.)​","type":1,"pageTitle":"Lena C","url":"evaluation/Lena C/#c-code-quality-15--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)❌ Use destructors when things need to be destroyed at the end.❌ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Lena C","url":"evaluation/Lena C/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Leo S","type":0,"sectionRef":"#","url":"evaluation/Leo S/","content":"","keywords":""},{"title":"Tools (1.5 / 3 pts.)​","type":1,"pageTitle":"Leo S","url":"evaluation/Leo S/#tools-15--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson❌ Have a .clang-format file, and apply it to your codebase☁️ Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (7.5 / 12 pts.)​","type":1,"pageTitle":"Leo S","url":"evaluation/Leo S/#clean-code-75--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)❌ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)❌ Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2 / 3 pts.)​","type":1,"pageTitle":"Leo S","url":"evaluation/Leo S/#c-code-quality-2--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.❌ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Leo S","url":"evaluation/Leo S/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Lilou B","type":0,"sectionRef":"#","url":"evaluation/Lilou B/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Lilou B","url":"evaluation/Lilou B/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (6.5 / 12 pts.)​","type":1,"pageTitle":"Lilou B","url":"evaluation/Lilou B/#clean-code-65--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)❌ Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ❌ Hard to understand or misleading names (Naming)❌ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (1.5 / 3 pts.)​","type":1,"pageTitle":"Lilou B","url":"evaluation/Lilou B/#c-code-quality-15--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)❌ Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Lilou B","url":"evaluation/Lilou B/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Lila C","type":0,"sectionRef":"#","url":"evaluation/Lila C/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Lila C","url":"evaluation/Lila C/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (8 / 12 pts.)​","type":1,"pageTitle":"Lila C","url":"evaluation/Lila C/#clean-code-8--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)❌ Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ❌ Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2 / 3 pts.)​","type":1,"pageTitle":"Lila C","url":"evaluation/Lila C/#c-code-quality-2--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Lila C","url":"evaluation/Lila C/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Logan A","type":0,"sectionRef":"#","url":"evaluation/Logan A/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Logan A","url":"evaluation/Logan A/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (10 / 12 pts.)​","type":1,"pageTitle":"Logan A","url":"evaluation/Logan A/#clean-code-10--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)🌞 Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)☁️ Use encapsulation when appropriate (public / private) (Design cohesive classes)🌞 Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)☁️ Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (1.5 / 3 pts.)​","type":1,"pageTitle":"Logan A","url":"evaluation/Logan A/#c-code-quality-15--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)❌ Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (4 / 4 pts.)​","type":1,"pageTitle":"Logan A","url":"evaluation/Logan A/#investment-4--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be🌞 Extend your project with additional features "},{"title":"Lou B","type":0,"sectionRef":"#","url":"evaluation/Lou B/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Lou B","url":"evaluation/Lou B/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (8.5 / 12 pts.)​","type":1,"pageTitle":"Lou B","url":"evaluation/Lou B/#clean-code-85--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)🌞 Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)☁️ Use encapsulation when appropriate (public / private) (Design cohesive classes)🌞 Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)❌ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2.5 / 3 pts.)​","type":1,"pageTitle":"Lou B","url":"evaluation/Lou B/#c-code-quality-25--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Lou B","url":"evaluation/Lou B/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Maely D","type":0,"sectionRef":"#","url":"evaluation/Maely D/","content":"","keywords":""},{"title":"Tools (3 pts.)​","type":1,"pageTitle":"Maely D","url":"evaluation/Maely D/#tools-3-pts","content":"➕ What you should do: ☁️ Follow the good practices of the Git lesson☁️ Have a .clang-format file, and apply it to your codebase☁️ Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: ☁️ Committing unwanted files like your build folder (see .gitignore)☁️ Making no commits until near the end of the semester "},{"title":"Clean Code (12 pts.)​","type":1,"pageTitle":"Maely D","url":"evaluation/Maely D/#clean-code-12-pts","content":"➕ What you should do: ☁️ Write many small functions (Write small functions)☁️ Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)☁️ Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ☁️ Hard to understand or misleading names (Naming)☁️ Duplicated code (DRY: Don't repeat yourself)☁️ Overly complicated code☁️ Global variables "},{"title":"C++ Code Quality (3 pts.)​","type":1,"pageTitle":"Maely D","url":"evaluation/Maely D/#c-code-quality-3-pts","content":"➕ What you should do: ☁️ Use range-based loops or algorithms, instead of raw loops (STL algorithms)☁️ Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: ☁️ Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)☁️ Forgetting #pragma once in your headers☁️ Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (4 pts.)​","type":1,"pageTitle":"Maely D","url":"evaluation/Maely D/#investment-4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Lucie G","type":0,"sectionRef":"#","url":"evaluation/Lucie G/","content":"","keywords":""},{"title":"Tools (2 / 3 pts.)​","type":1,"pageTitle":"Lucie G","url":"evaluation/Lucie G/#tools-2--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson☁️ Have a .clang-format file, and apply it to your codebase☁️ Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (11 / 12 pts.)​","type":1,"pageTitle":"Lucie G","url":"evaluation/Lucie G/#clean-code-11--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)☁️ Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ☁️ Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2.5 / 3 pts.)​","type":1,"pageTitle":"Lucie G","url":"evaluation/Lucie G/#c-code-quality-25--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Lucie G","url":"evaluation/Lucie G/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Marion B","type":0,"sectionRef":"#","url":"evaluation/Marion B/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Marion B","url":"evaluation/Marion B/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (11 / 12 pts.)​","type":1,"pageTitle":"Marion B","url":"evaluation/Marion B/#clean-code-11--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)🌞 Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)🌞 Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ☁️ Hard to understand or misleading names (Naming)☁️ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (3 / 3 pts.)​","type":1,"pageTitle":"Marion B","url":"evaluation/Marion B/#c-code-quality-3--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.🌞 Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Marion B","url":"evaluation/Marion B/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Mailis B","type":0,"sectionRef":"#","url":"evaluation/Mailis B/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Mailis B","url":"evaluation/Mailis B/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (8.5 / 12 pts.)​","type":1,"pageTitle":"Mailis B","url":"evaluation/Mailis B/#clean-code-85--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)🌞 Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)☁️ Use encapsulation when appropriate (public / private) (Design cohesive classes)🌞 Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)❌ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2.5 / 3 pts.)​","type":1,"pageTitle":"Mailis B","url":"evaluation/Mailis B/#c-code-quality-25--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Mailis B","url":"evaluation/Mailis B/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Matteo M","type":0,"sectionRef":"#","url":"evaluation/Matteo M/","content":"","keywords":""},{"title":"Tools (2 / 3 pts.)​","type":1,"pageTitle":"Matteo M","url":"evaluation/Matteo M/#tools-2--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson☁️ Have a .clang-format file, and apply it to your codebase☁️ Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (11 / 12 pts.)​","type":1,"pageTitle":"Matteo M","url":"evaluation/Matteo M/#clean-code-11--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)☁️ Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ☁️ Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2.5 / 3 pts.)​","type":1,"pageTitle":"Matteo M","url":"evaluation/Matteo M/#c-code-quality-25--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Matteo M","url":"evaluation/Matteo M/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Matheo P","type":0,"sectionRef":"#","url":"evaluation/Matheo P/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Matheo P","url":"evaluation/Matheo P/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (9 / 12 pts.)​","type":1,"pageTitle":"Matheo P","url":"evaluation/Matheo P/#clean-code-9--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)❌ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)❌ Use encapsulation when appropriate (public / private) (Design cohesive classes)🌞 Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)❌ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2 / 3 pts.)​","type":1,"pageTitle":"Matheo P","url":"evaluation/Matheo P/#c-code-quality-2--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)☁️ Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (3 / 4 pts.)​","type":1,"pageTitle":"Matheo P","url":"evaluation/Matheo P/#investment-3--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Maureen G","type":0,"sectionRef":"#","url":"evaluation/Maureen G/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Maureen G","url":"evaluation/Maureen G/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (7 / 12 pts.)​","type":1,"pageTitle":"Maureen G","url":"evaluation/Maureen G/#clean-code-7--12-pts","content":"➕ What you should do: ☁️ Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)🌞 Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)❌ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ❌ Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (1.5 / 3 pts.)​","type":1,"pageTitle":"Maureen G","url":"evaluation/Maureen G/#c-code-quality-15--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)☁️ Use destructors when things need to be destroyed at the end.❌ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)☁️ Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Maureen G","url":"evaluation/Maureen G/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Maxime V","type":0,"sectionRef":"#","url":"evaluation/Maxime V/","content":"","keywords":""},{"title":"Tools (2 / 3 pts.)​","type":1,"pageTitle":"Maxime V","url":"evaluation/Maxime V/#tools-2--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson❌ Have a .clang-format file, and apply it to your codebase☁️ Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (7 / 12 pts.)​","type":1,"pageTitle":"Maxime V","url":"evaluation/Maxime V/#clean-code-7--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)☁️ Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ☁️ Hard to understand or misleading names (Naming)☁️ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2 / 3 pts.)​","type":1,"pageTitle":"Maxime V","url":"evaluation/Maxime V/#c-code-quality-2--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)☁️ Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: ☁️ Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)☁️ Forgetting #pragma once in your headers☁️ Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (3 / 4 pts.)​","type":1,"pageTitle":"Maxime V","url":"evaluation/Maxime V/#investment-3--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Matthieu M","type":0,"sectionRef":"#","url":"evaluation/Matthieu M/","content":"","keywords":""},{"title":"Tools (1.5 / 3 pts.)​","type":1,"pageTitle":"Matthieu M","url":"evaluation/Matthieu M/#tools-15--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson❌ Have a .clang-format file, and apply it to your codebase❌ Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (7.5 / 12 pts.)​","type":1,"pageTitle":"Matthieu M","url":"evaluation/Matthieu M/#clean-code-75--12-pts","content":"➕ What you should do: ☁️ Write many small functions (Write small functions)☁️ Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)❌ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code☁️ Global variables "},{"title":"C++ Code Quality (2 / 3 pts.)​","type":1,"pageTitle":"Matthieu M","url":"evaluation/Matthieu M/#c-code-quality-2--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Matthieu M","url":"evaluation/Matthieu M/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Marianne K","type":0,"sectionRef":"#","url":"evaluation/Marianne K/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Marianne K","url":"evaluation/Marianne K/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (9 / 12 pts.)​","type":1,"pageTitle":"Marianne K","url":"evaluation/Marianne K/#clean-code-9--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)❌ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)❌ Use encapsulation when appropriate (public / private) (Design cohesive classes)🌞 Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)❌ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2 / 3 pts.)​","type":1,"pageTitle":"Marianne K","url":"evaluation/Marianne K/#c-code-quality-2--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)☁️ Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (3 / 4 pts.)​","type":1,"pageTitle":"Marianne K","url":"evaluation/Marianne K/#investment-3--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Melodie K","type":0,"sectionRef":"#","url":"evaluation/Melodie K/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Melodie K","url":"evaluation/Melodie K/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (7 / 12 pts.)​","type":1,"pageTitle":"Melodie K","url":"evaluation/Melodie K/#clean-code-7--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2 / 3 pts.)​","type":1,"pageTitle":"Melodie K","url":"evaluation/Melodie K/#c-code-quality-2--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Melodie K","url":"evaluation/Melodie K/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Nina G","type":0,"sectionRef":"#","url":"evaluation/Nina G/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Nina G","url":"evaluation/Nina G/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (6.5 / 12 pts.)​","type":1,"pageTitle":"Nina G","url":"evaluation/Nina G/#clean-code-65--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)❌ Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ❌ Hard to understand or misleading names (Naming)❌ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (1.5 / 3 pts.)​","type":1,"pageTitle":"Nina G","url":"evaluation/Nina G/#c-code-quality-15--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)❌ Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Nina G","url":"evaluation/Nina G/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Nolwenn G","type":0,"sectionRef":"#","url":"evaluation/Nolwenn G/","content":"","keywords":""},{"title":"Tools (2 / 3 pts.)​","type":1,"pageTitle":"Nolwenn G","url":"evaluation/Nolwenn G/#tools-2--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson☁️ Have a .clang-format file, and apply it to your codebase☁️ Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (5 / 12 pts.)​","type":1,"pageTitle":"Nolwenn G","url":"evaluation/Nolwenn G/#clean-code-5--12-pts","content":"➕ What you should do: ❌ Write many small functions (Write small functions)❌ Write small classes (Design cohesive classes)❌ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)❌ Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ☁️ Hard to understand or misleading names (Naming)☁️ Duplicated code (DRY: Don't repeat yourself)☁️ Overly complicated code☁️ Global variables "},{"title":"C++ Code Quality (1 / 3 pts.)​","type":1,"pageTitle":"Nolwenn G","url":"evaluation/Nolwenn G/#c-code-quality-1--3-pts","content":"➕ What you should do: ❌ Use range-based loops or algorithms, instead of raw loops (STL algorithms)❌ Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Nolwenn G","url":"evaluation/Nolwenn G/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Romane M","type":0,"sectionRef":"#","url":"evaluation/Romane M/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Romane M","url":"evaluation/Romane M/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (7 / 12 pts.)​","type":1,"pageTitle":"Romane M","url":"evaluation/Romane M/#clean-code-7--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2 / 3 pts.)​","type":1,"pageTitle":"Romane M","url":"evaluation/Romane M/#c-code-quality-2--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Romane M","url":"evaluation/Romane M/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Sara G","type":0,"sectionRef":"#","url":"evaluation/Sara G/","content":"","keywords":""},{"title":"Tools (2 / 3 pts.)​","type":1,"pageTitle":"Sara G","url":"evaluation/Sara G/#tools-2--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson☁️ Have a .clang-format file, and apply it to your codebase☁️ Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (5 / 12 pts.)​","type":1,"pageTitle":"Sara G","url":"evaluation/Sara G/#clean-code-5--12-pts","content":"➕ What you should do: ❌ Write many small functions (Write small functions)❌ Write small classes (Design cohesive classes)❌ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)❌ Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ☁️ Hard to understand or misleading names (Naming)☁️ Duplicated code (DRY: Don't repeat yourself)☁️ Overly complicated code☁️ Global variables "},{"title":"C++ Code Quality (1 / 3 pts.)​","type":1,"pageTitle":"Sara G","url":"evaluation/Sara G/#c-code-quality-1--3-pts","content":"➕ What you should do: ❌ Use range-based loops or algorithms, instead of raw loops (STL algorithms)❌ Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Sara G","url":"evaluation/Sara G/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Sara L","type":0,"sectionRef":"#","url":"evaluation/Sara L/","content":"","keywords":""},{"title":"Tools (2 / 3 pts.)​","type":1,"pageTitle":"Sara L","url":"evaluation/Sara L/#tools-2--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson☁️ Have a .clang-format file, and apply it to your codebase☁️ Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (7 / 12 pts.)​","type":1,"pageTitle":"Sara L","url":"evaluation/Sara L/#clean-code-7--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)☁️ Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)🌞 Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)❌ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (1.5 / 3 pts.)​","type":1,"pageTitle":"Sara L","url":"evaluation/Sara L/#c-code-quality-15--3-pts","content":"➕ What you should do: ❌ Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2 / 4 pts.)​","type":1,"pageTitle":"Sara L","url":"evaluation/Sara L/#investment-2--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Segolene L","type":0,"sectionRef":"#","url":"evaluation/Segolene L/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Segolene L","url":"evaluation/Segolene L/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (8 / 12 pts.)​","type":1,"pageTitle":"Segolene L","url":"evaluation/Segolene L/#clean-code-8--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ❌ Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (1.5 / 3 pts.)​","type":1,"pageTitle":"Segolene L","url":"evaluation/Segolene L/#c-code-quality-15--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)❌ Use destructors when things need to be destroyed at the end.❌ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (3 / 4 pts.)​","type":1,"pageTitle":"Segolene L","url":"evaluation/Segolene L/#investment-3--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Salome T","type":0,"sectionRef":"#","url":"evaluation/Salome T/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Salome T","url":"evaluation/Salome T/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (7.5 / 12 pts.)​","type":1,"pageTitle":"Salome T","url":"evaluation/Salome T/#clean-code-75--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ☁️ Hard to understand or misleading names (Naming)❌ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2 / 3 pts.)​","type":1,"pageTitle":"Salome T","url":"evaluation/Salome T/#c-code-quality-2--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)❌ Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (3 / 4 pts.)​","type":1,"pageTitle":"Salome T","url":"evaluation/Salome T/#investment-3--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class🌞 Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Tancrede G","type":0,"sectionRef":"#","url":"evaluation/Tancrede G/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Tancrede G","url":"evaluation/Tancrede G/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (7.5 / 12 pts.)​","type":1,"pageTitle":"Tancrede G","url":"evaluation/Tancrede G/#clean-code-75--12-pts","content":"➕ What you should do: ☁️ Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2.5 / 3 pts.)​","type":1,"pageTitle":"Tancrede G","url":"evaluation/Tancrede G/#c-code-quality-25--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (3 / 4 pts.)​","type":1,"pageTitle":"Tancrede G","url":"evaluation/Tancrede G/#investment-3--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Tanya F","type":0,"sectionRef":"#","url":"evaluation/Tanya F/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Tanya F","url":"evaluation/Tanya F/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (10 / 12 pts.)​","type":1,"pageTitle":"Tanya F","url":"evaluation/Tanya F/#clean-code-10--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)🌞 Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)🌞 Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ☁️ Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (1.5 / 3 pts.)​","type":1,"pageTitle":"Tanya F","url":"evaluation/Tanya F/#c-code-quality-15--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)❌ Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (2.5 / 4 pts.)​","type":1,"pageTitle":"Tanya F","url":"evaluation/Tanya F/#investment-25--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Thomas G","type":0,"sectionRef":"#","url":"evaluation/Thomas G/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Thomas G","url":"evaluation/Thomas G/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (11 / 12 pts.)​","type":1,"pageTitle":"Thomas G","url":"evaluation/Thomas G/#clean-code-11--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)🌞 Use strong types (Strong Types)🌞 Use encapsulation when appropriate (public / private) (Design cohesive classes)🌞 Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (2.5 / 3 pts.)​","type":1,"pageTitle":"Thomas G","url":"evaluation/Thomas G/#c-code-quality-25--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)🌞 Use destructors when things need to be destroyed at the end.❌ Use const when appropriate (const)🌞 Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (4 / 4 pts.)​","type":1,"pageTitle":"Thomas G","url":"evaluation/Thomas G/#investment-4--4-pts","content":"➕ What you should do: 🌞 Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be🌞 Extend your project with additional features "},{"title":"Titouan M","type":0,"sectionRef":"#","url":"evaluation/Titouan M/","content":"","keywords":""},{"title":"Tools (3 pts.)​","type":1,"pageTitle":"Titouan M","url":"evaluation/Titouan M/#tools-3-pts","content":"➕ What you should do: ☁️ Follow the good practices of the Git lesson☁️ Have a .clang-format file, and apply it to your codebase☁️ Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: ☁️ Committing unwanted files like your build folder (see .gitignore)☁️ Making no commits until near the end of the semester "},{"title":"Clean Code (12 pts.)​","type":1,"pageTitle":"Titouan M","url":"evaluation/Titouan M/#clean-code-12-pts","content":"➕ What you should do: ☁️ Write many small functions (Write small functions)☁️ Write small classes (Design cohesive classes)☁️ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)☁️ Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: ☁️ Hard to understand or misleading names (Naming)☁️ Duplicated code (DRY: Don't repeat yourself)☁️ Overly complicated code☁️ Global variables "},{"title":"C++ Code Quality (3 pts.)​","type":1,"pageTitle":"Titouan M","url":"evaluation/Titouan M/#c-code-quality-3-pts","content":"➕ What you should do: ☁️ Use range-based loops or algorithms, instead of raw loops (STL algorithms)☁️ Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: ☁️ Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)☁️ Forgetting #pragma once in your headers☁️ Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (4 pts.)​","type":1,"pageTitle":"Titouan M","url":"evaluation/Titouan M/#investment-4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Valentin G","type":0,"sectionRef":"#","url":"evaluation/Valentin G/","content":"","keywords":""},{"title":"Tools (3 / 3 pts.)​","type":1,"pageTitle":"Valentin G","url":"evaluation/Valentin G/#tools-3--3-pts","content":"➕ What you should do: 🌞 Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: 🌞 Committing unwanted files like your build folder (see .gitignore)🌞 Making no commits until near the end of the semester "},{"title":"Clean Code (10 / 12 pts.)​","type":1,"pageTitle":"Valentin G","url":"evaluation/Valentin G/#clean-code-10--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)🌞 Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)☁️ Use encapsulation when appropriate (public / private) (Design cohesive classes)🌞 Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)🌞 Duplicated code (DRY: Don't repeat yourself)☁️ Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (1.5 / 3 pts.)​","type":1,"pageTitle":"Valentin G","url":"evaluation/Valentin G/#c-code-quality-15--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)❌ Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (4 / 4 pts.)​","type":1,"pageTitle":"Valentin G","url":"evaluation/Valentin G/#investment-4--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be🌞 Extend your project with additional features "},{"title":"Introduction","type":0,"sectionRef":"#","url":"lessons/","content":"","keywords":""},{"title":"Goals​","type":1,"pageTitle":"Introduction","url":"lessons/#goals","content":"GOAL In this class we will focus on writing Clean Code, i.e. code that is correct and maintainable. Clean code is an essential concern when you start building larger projects that are meant to last for years. Anyone should be able to pick up your code and – within a reasonable time frame – understand what it does, what its role inside the project is, and how to modify it. Clean code is both a concern at the architectural level (organisation between modules and classes) and at the granular level (organisation inside a given class or function). We will see basic coding habits that make your code more expressive, general principles that help you organize your code, a few amazing design patterns, and we will get into the habit of using meaningful names and writing documentation and tests. We will also discover the amazing tools that are available to make our job easier and way more enjoyable. It's not about C++ Although this class makes use of C++, most of its content will be applicable to any language and any kind of programming project. "},{"title":"Give me feedback​","type":1,"pageTitle":"Introduction","url":"lessons/#give-me-feedback","content":"I tried my best to deliver a great learning experience to you. I am still a novice teacher though (and even if I were experienced, one never runs out of things to learn anyways). So your feedback is more than welcome and I will happily improve my classes with your help! To do so, feel free to reach out to me directly or raise an issue on GitHub. "},{"title":"Zacharie P","type":0,"sectionRef":"#","url":"evaluation/Zacharie P/","content":"","keywords":""},{"title":"Tools (1.5 / 3 pts.)​","type":1,"pageTitle":"Zacharie P","url":"evaluation/Zacharie P/#tools-15--3-pts","content":"➕ What you should do: ❌ Follow the good practices of the Git lesson🌞 Have a .clang-format file, and apply it to your codebase🌞 Have a .clang-tidy file, and fix the problems it shows you, or ask the teacher if you don't understand what the warning means or don't know how to fix it. ➖ What you shouldn't do: ❌ Committing unwanted files like your build folder (see .gitignore)❌ Making no commits until near the end of the semester "},{"title":"Clean Code (6.5 / 12 pts.)​","type":1,"pageTitle":"Zacharie P","url":"evaluation/Zacharie P/#clean-code-65--12-pts","content":"➕ What you should do: 🌞 Write many small functions (Write small functions)🌞 Write small classes (Design cohesive classes)❌ Write small structs (Use structs to group data)☁️ Use strong types (Strong Types)❌ Use encapsulation when appropriate (public / private) (Design cohesive classes)☁️ Use free functions as often as possible, and methods only when appropriate (Prefer free functions)☁️ Minimize dependencies ➖ What you shouldn't do: 🌞 Hard to understand or misleading names (Naming)☁️ Duplicated code (DRY: Don't repeat yourself)🌞 Overly complicated code🌞 Global variables "},{"title":"C++ Code Quality (1.5 / 3 pts.)​","type":1,"pageTitle":"Zacharie P","url":"evaluation/Zacharie P/#c-code-quality-15--3-pts","content":"➕ What you should do: 🌞 Use range-based loops or algorithms, instead of raw loops (STL algorithms)❌ Use destructors when things need to be destroyed at the end.☁️ Use const when appropriate (const)☁️ Use lambdas when appropriate (Lambda functions) ➖ What you shouldn't do: 🌞 Using new instead of a stack allocation or a smart pointer or a standard container (std::vector)🌞 Forgetting #pragma once in your headers🌞 Using 1 and 0 instead of true and false for your booleans "},{"title":"Investment (1 / 4 pts.)​","type":1,"pageTitle":"Zacharie P","url":"evaluation/Zacharie P/#investment-1--4-pts","content":"➕ What you should do: ☁️ Ask questions and participate in class☁️ Take my feedback into account, improve your old code if need be☁️ Extend your project with additional features "},{"title":"Advanced Git features","type":0,"sectionRef":"#","url":"lessons/advanced-git-features/","content":"","keywords":""},{"title":"Branches​","type":1,"pageTitle":"Advanced Git features","url":"lessons/advanced-git-features/#branches","content":""},{"title":"Stashes​","type":1,"pageTitle":"Advanced Git features","url":"lessons/advanced-git-features/#stashes","content":""},{"title":"Amend​","type":1,"pageTitle":"Advanced Git features","url":"lessons/advanced-git-features/#amend","content":"Write a commit but don't push it, you can modify it later. It can be good to save your progress even if it doesn't compile yet and you don't want to push it. "},{"title":"Rebase​","type":1,"pageTitle":"Advanced Git features","url":"lessons/advanced-git-features/#rebase","content":"Like amend, but more powerful caution Don't amend or rebase if someone has already pulled your inital commit and starting working on top of it! It will mess up the Git history and merging will be impossible. "},{"title":"std::array","type":0,"sectionRef":"#","url":"lessons/array/","content":"std::array","keywords":""},{"title":"Avoid nested namespaces","type":0,"sectionRef":"#","url":"lessons/avoid-nested-namespaces/","content":"Avoid nested namespaces https://youtu.be/xu7q8dGvuwk?t=1198","keywords":""},{"title":"Avoid dead code","type":0,"sectionRef":"#","url":"lessons/avoid-dead-code/","content":"Avoid dead code Don't leave commented out blocks in your code. If for some reason you want to do so, then leave a comment at the top explaining your reason ; otherwise it is very hard for readers to know what the purpose of that code is and what to do with it : is it still relevant ? is it another option ? or is it just junk ? Example from real code from a company whose name I shall not mention: void Start() { // Utils.SetEnglishLanguage(); // SetupSavedReportsFolder(); // var commandLine = GetCommandLine(); // _commandLineArguments = new CommandLineArguments(commandLine); // // set a specific GUID for the first report // if (_commandLineArguments.ContainsKey(&quot;ReportGuid&quot;)) // BloombergUnityClient.Instance.ReportGuid = Guid.Parse(_commandLineArguments[&quot;ReportGuid&quot;]); // // set a specific address to send the report to. // if (_commandLineArguments.ContainsKey(&quot;ServerAddress&quot;)) // BloombergUnityClient.Instance.config.bloombergServerHost = _commandLineArguments[&quot;ServerAddress&quot;]; // // set a specific TCP port to send the report to. // if (_commandLineArguments.ContainsKey(&quot;ServerPort&quot;)) // BloombergUnityClient.Instance.config.bloombergServerPort = Convert.ToUInt16(_commandLineArguments[&quot;ServerPort&quot;]); // // set the Transmission mode to be use to send the report // if (_commandLineArguments.ContainsKey(&quot;TransmissionMode&quot;)) // BloombergUnityClient.Instance.config.transmissionMode = (BloombergTransmissionMode) Enum.Parse(typeof(BloombergTransmissionMode), _commandLineArguments[&quot;TransmissionMode&quot;]); // // URL to use to get temporary access to write objects (breport) // if (_commandLineArguments.ContainsKey(&quot;S3_MainAPIUrl&quot;)) // BloombergUnityClient.Instance.S3_MainAPIUrl = _commandLineArguments[&quot;S3_MainAPIUrl&quot;]; // // MyServices specific to initialize the session // if (_commandLineArguments.ContainsKey(&quot;US_ApplicationId&quot;)) // { // try // { // _myServices = new MyServices(); // _myServices?.Initialize(_commandLineArguments[&quot;US_ApplicationId&quot;], _commandLineArguments[&quot;US_Email&quot;], _commandLineArguments[&quot;US_Password&quot;]); // } // catch (Exception e) // { // Debug.LogWarning($&quot;MyServices creation failed /r/n {e}&quot;); // } // } BloombergBootstrap.Bootstrap(); Reporter.Initialize(); SetCommandLine(); SetSettings(); Application.logMessageReceivedThreaded += OnLog; } Copy","keywords":""},{"title":"auto","type":0,"sectionRef":"#","url":"lessons/auto/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"auto","url":"lessons/auto/#brief","content":"Sometimes the type of a variable is obvious with the context, and a type declaration would be redundant. In such cases you can use auto instead: std::unique_ptr&lt;MyClass&gt; my_ptr = std::make_unique&lt;MyClass&gt;(); // Bad: we are saying twice that we want a unique pointer to MyClass auto my_ptr = std::make_unique&lt;MyClass&gt;(); // Good: we don't repeat ourselves Copy But there is more! Sometimes, even if the type is not obvious, you don't want to hardcode it! Using auto can make refactoring easier and avoid unwanted implicit conversions. You can find this discussion in more details here at 28:23. Of course there are also good reasons not to use auto in some cases. It is up to you to make that decision. tip Optimize for the reader, not the writer! You write a piece of code once, and then it will be read many many times by many people in the years to come. So facilitating the life of the readers is way more important than facilitating that of the writer. In short: we don't care if you have to type more characters, we only care about the readability of the code. So &quot;auto saves me some typing&quot; is not a good reason, but &quot;auto is more readable&quot; is. And in the cases where auto is less readable, then don't use auto!  "},{"title":"assert","type":0,"sectionRef":"#","url":"lessons/assert/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"assert","url":"lessons/assert/#brief","content":"assert is a pretty useful debugging tool. It allows you to make sure that a function is used properly by the outside world. And you don't even pay a performance cost for it because this check is removed once you build in release mode. But this also means that once in release mode you have no guarantee that the requirements are met; this means that in some cases it is better to enforce those checks with another mechanism, such as exceptions, which will remain in release mode. "},{"title":"assert​","type":1,"pageTitle":"assert","url":"lessons/assert/#assert","content":"void serve_alcohol(Person&amp; person) { assert(person.age() &gt;= 18); // Bad, this kind of check needs to remain in release mode! Because `person` could be anyone and you don't have a guarantee that this check is done anywhere. person.drink(alcohol()); } Copy Example from the Dear ImGui library assert(g.WithinFrameScope &amp;&amp; &quot;You forgot to call ImGui::NewFrame()&quot;); // Good, this does trigger when the developer using the library does something wrong, and tells them what they did wrong. Once the error has been detected and fixed in the code, we can have the guarantee that it will never happen again even in release. // Basically since this function does not depend on user input but on usage by the programmer it is safe to use an assert. Copy "},{"title":"static_assert​","type":1,"pageTitle":"assert","url":"lessons/assert/#static_assert","content":"static_assert happens at compile time, whereas assert happens at runtime. It is used, just like assert, to make sure that a function is used properly. It is especially useful in template contexts if you require that a type has certain properties: template&lt;typename T&gt; T compute_something(T t) { static_assert(std::is_floating_point&lt;T&gt;::value, // Good, fail early rather than see the function break in unexpected ways later &quot;compute_something() only works for float and double!&quot;); // ... } Copy Example from the Cereal library // Great, Cereal does some metaprogramming magic to help you use the library correctly // and gives you clear error messages in case you do something wrong. template &lt;class T, class A&gt; struct has_member_save : std::integral_constant&lt;bool, detail::has_member_save_impl&lt;T, A&gt;::value&gt; { typedef typename detail::has_member_save_impl&lt;T, A&gt; check; static_assert( check::value || !check::not_const_type, &quot;cereal detected a non-const save. \\n &quot; &quot;save member functions must always be const&quot; ); }; Copy "},{"title":"Avoid unnecessary condition nesting","type":0,"sectionRef":"#","url":"lessons/avoid-unnecessary-condition-nesting/","content":"Avoid unnecessary condition nesting F.56: Avoid unnecessary condition nesting. Going Further CodeAesthetic, Why You Shouldn't Nest Your Code (8min)","keywords":""},{"title":"Avoid premature optimization","type":0,"sectionRef":"#","url":"lessons/avoid-premature-optimization/","content":"Avoid premature optimization","keywords":""},{"title":"Cache and Branches","type":0,"sectionRef":"#","url":"lessons/cache-and-branches/","content":"Cache and Branches https://youtu.be/EmzdmqUWq3o","keywords":""},{"title":"Continuous Integration (CI)","type":0,"sectionRef":"#","url":"lessons/ci/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Continuous Integration (CI)","url":"lessons/ci/#brief","content":"Continuous Integration is the process of testing your code automatically whenever you make changes to it. For example, you can set it up with GitHub so that, whenever you make a commit, a server will automatically try to build your code and run your tests and, if anything fails, it will warn you. CI is an essential part of development as it ensures that you notice immediately if you break something. It also allows you to test your code on all the platforms (Windows, Linux, MacOS, ...) and all the compilers (Clang, GCC, MSVC, ...) and benefit from all the warnings they have to offer. You can see the progress (and eventual errors) of your tests in the Actions tab of your GitHub repository.  You will also receive an email if something fails. "},{"title":"How to​","type":1,"pageTitle":"Continuous Integration (CI)","url":"lessons/ci/#how-to","content":"To learn more about the specifics of GitHub Actions for C++, see this article. Or you can check out how CI is set up in this template. info It is also possible to do this with GitLab (and many others) but you will have to look it up on your own. "},{"title":"clangd","type":0,"sectionRef":"#","url":"lessons/clangd/","content":"clangd If you are familiar with IntelliSense (which is installed by default in Visual Studio and Visual Studio Code), clangd is the same kind of thing, but better (less laggy, more complete). It will provide autocompletion, suggestions, detect bugs, etc. First, install the clangd extension: vscode-clangd. It should then prompt you to disable IntelliSense: say yes. If you miss that step, go in the Settings, search for C_Cpp.intelliSenseEngine and set it to Disabled.It should then prompt you to download the actual language server: say yes. If it doesn't show up, then CTRL+SHIFT+P and run clangd: Download language server. If it is unable to download it, you can download it manually here.Now go to your Settings (CTRL+,), search for clangd arguments and add --compile-commands-dir=${workspaceFolder}/buildNow install Ninja. Then, go back to your settings and set Cmake: Generator to Ninja.You might need to close VS Code, delete your build folder (if it exists), and open VS Code again. You should now be good to go! (If VSCode is not able to provide autocompletion, then something went wrong during the installation of clangd.) tip clangd adds these things called Inlay Hints:If you don't want them you can disable them in your VS Code settings:","keywords":""},{"title":"Code reviews","type":0,"sectionRef":"#","url":"lessons/code-reviews/","content":"Code reviews https://youtu.be/ta3S8CRN2TM?t=878","keywords":""},{"title":"Classes and Structs","type":0,"sectionRef":"#","url":"lessons/classes-and-structs/","content":"","keywords":""},{"title":"Classes​","type":1,"pageTitle":"Classes and Structs","url":"lessons/classes-and-structs/#classes","content":" "},{"title":"Classes vs Structs​","type":1,"pageTitle":"Classes and Structs","url":"lessons/classes-and-structs/#classes-vs-structs","content":" "},{"title":"How to write a class​","type":1,"pageTitle":"Classes and Structs","url":"lessons/classes-and-structs/#how-to-write-a-class","content":" "},{"title":"Visibility (public / private)​","type":1,"pageTitle":"Classes and Structs","url":"lessons/classes-and-structs/#visibility-public--private","content":" "},{"title":"The this keyword​","type":1,"pageTitle":"Classes and Structs","url":"lessons/classes-and-structs/#the-this-keyword","content":" "},{"title":"Constructors​","type":1,"pageTitle":"Classes and Structs","url":"lessons/classes-and-structs/#constructors","content":"     "},{"title":"Destructors​","type":1,"pageTitle":"Classes and Structs","url":"lessons/classes-and-structs/#destructors","content":" "},{"title":"Copy constructor​","type":1,"pageTitle":"Classes and Structs","url":"lessons/classes-and-structs/#copy-constructor","content":" "},{"title":"The Command pattern","type":0,"sectionRef":"#","url":"lessons/command/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"The Command pattern","url":"lessons/command/#brief","content":""},{"title":"Remarks​","type":1,"pageTitle":"The Command pattern","url":"lessons/command/#remarks","content":"Command is similar to Singleton in that it gives everyone access to a lot of things without having to declare the dependencies in the signature of the function. But the ig difference is that with Command you just express your intent, you are not tied to any specific implementation and we can always change easily how the command is executed. And other parts of the code are never affect by the fact that you submit a command, whereas changing the state of a singleton can impact and annoy everyone. Singleton has state that people might be depending on, whereas Command is just equivalent to calling a function. "},{"title":"Consistency in style","type":0,"sectionRef":"#","url":"lessons/consistency-in-style/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Consistency in style","url":"lessons/consistency-in-style/#brief","content":"Be consistent with the conventions you choose (e.g. camelCase vs snake_case, prefix of member variables etc.). "},{"title":"Why bother?​","type":1,"pageTitle":"Consistency in style","url":"lessons/consistency-in-style/#why-bother","content":"When your brain gets used to a convention you will find it easier to read and understand the code. On the contrary if a project breaks its own convention all the time it can be confusing. To help you in this task you have formatting tools and static analysers which will do most of the job for you. "},{"title":"Don't be too religious​","type":1,"pageTitle":"Consistency in style","url":"lessons/consistency-in-style/#dont-be-too-religious","content":"You might think that the convention you use is the best – everyone does – but it's all about trade-offs and there is no one single right answer. A new project is a great opportunity to give another convention a shot. Don't judge conventions solely on your expectations, because we are so used to the one we use that all the other feel weird at first sight. But by trying a convention for a few weeks your view of it will change. This happened to me with snake_case; I used to think that it was weird and ugly, but now I think this is the most readable convention of them all because the words are clearly separated and it helps a lot, especially with longer names. "},{"title":"C++ casts","type":0,"sectionRef":"#","url":"lessons/cpp-casts/","content":"C++ casts ","keywords":""},{"title":"const","type":0,"sectionRef":"#","url":"lessons/const/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"const","url":"lessons/const/#brief","content":"   "},{"title":"When not to use const​","type":1,"pageTitle":"const","url":"lessons/const/#when-not-to-use-const","content":"When returning by valueOn member variables  On arguments passed by copy it is up to you, doesn't add much semantic, doesn't prevent big bugs but can prevent small ones. "},{"title":"Bonus trick​","type":1,"pageTitle":"const","url":"lessons/const/#bonus-trick","content":"You can use lambdas for const variables that are complex to initialize. "},{"title":"Bad :( (because x is not const)​","type":1,"pageTitle":"const","url":"lessons/const/#bad--because-x-is-not-const","content":"enum class MyEnum { value0, value1, value2, }; int do_something(MyEnum my_enum) { int x; switch(my_enum) { case MyEnum::value0 : x = 17; break; case MyEnum::value1 : x = 5; break; case MyEnum::value2 : x = 30; break; default: x = 0; break; } // use x return x + 2; } int main() { return do_something(MyEnum::value1); } Copy "},{"title":"Good :)​","type":1,"pageTitle":"const","url":"lessons/const/#good-","content":"enum class MyEnum { value0, value1, value2, }; int do_something(MyEnum my_enum) { const int x = [my_enum]() { switch(my_enum) { case MyEnum::value0 : return 17; case MyEnum::value1 : return 5; case MyEnum::value2 : return 30; default: return 0; } }(); // parenthesis to call the lambda function that was just declared // use x return x + 2; } int main() { return do_something(MyEnum::value1); } Copy "},{"title":"Composition over Inheritance","type":0,"sectionRef":"#","url":"lessons/composition-over-inheritance/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#brief","content":"Inheritance is great, but its complex. It should therefore only be used in cases that absolutely require it and when no other simpler mechanism would be able to achieve the same job. Such simpler mechanisms include functions, function overloads, composition, function objects and templates. "},{"title":"Code reuse​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#code-reuse","content":"If you are using inheritance to reuse code, then hold your horses! There are simpler ways: Use functions to reuse logicUse composition to reuse member variables "},{"title":"What is composition?​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#what-is-composition","content":"In order to reuse member variables you can put them in a struct or class and add that struct as a member of the class that needs them. For example if many different classes need to have a Transform (a.k.a. a position, a rotation and a scale) you could have all your classes inherit from Transform, but you can also add Transform as an attribute of the classes instead: class Transform { vec3 position; vec3 rotation; vec3 scale; }; class Character { public: // functions that might use _transform if they need it private: Transform _transform; }; class Obstacle { public: // functions that might use _transform if they need it private: Transform _transform; }; Copy This gives you greater control over the API of the &quot;child&quot; classes. Because when you modify a parent class the change is necessarily reflected in all the children, which is often not desired. But often you end up needing to add something in the parent class because one specific child needs it, and by doing so you impose it on all the other children which don't necessarily need or want it. With composition you have greater control over that. And also composition naturally encourages you to write smaller classes instead of inheriting from one big mother class. "},{"title":"Polymorphism​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#polymorphism","content":"There are many ways of achieving polymorphism, and inheritance is only one of them! And there are also different kinds of polymorphism: static and dynamic. "},{"title":"Static​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#static","content":"Static polymorphism happens at compile time: it is therefore more performant, but can be used in fewer situations. Static polymorphism is achieved through templates. (And function overloads can help too): void do_something(int x) {/*...*/} void do_something(float x) {/*...*/} template&lt;typename T&gt; void complicated_function(T x) { // ... do_something(x); // This will use a different function depending on whether x is an int or a float // Our overload set has helped us doing polymorphism even though the `do_something` functions are simple and don't involve templates! // ... } Copy tip Prefer static polymorphism to dynamic polymorphism whenever possible. "},{"title":"Dynamic​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#dynamic","content":"Dynamic polymorphism allows you to change the behaviour of an object or function at runtime. This is typically the use case that people have for inheritance. But there are alternatives! std::variant and std::function. std::variant​ One thing to note is that inheritance allows anyone to subclass a type at any time. This is very generic, but also very rarely needed! Most of the time you will know in advance all the possible subtypes. For example you might by writing an abstract Camera class which has exactly two child classes: TrackballCamera and FreeflyCamera. In such cases using a std::variant will be more performant, and also express the semantic better: using Camera = std::variant&lt;TrackballCamera, FreeflyCamera&gt;; Copy Since all alternatives are known at compile time, the size of Camera is known too, which means it doesn't have to be allocated on the heap! No need for pointers, new or std::unique_ptr anymore: you can simply have a Camera my_camera on the stack and use it like any old regular variable. There are no problems with copying, no weird reference semantics, no problems at all! info One downside to std::variant is that the syntax is not as nice as it could be, and it might be simpler to use inheritance. This has to be taken into account when deciding between std::variant and inheritance, and I will not blame you if you decide to pay the performance cost of inheritance for the sole reason that it is simpler to write code with inheritance than with std::variant. (Although dealing with unique_ptr can be quite cumbersome too). But remember that in some cases std::variant will be simpler to use than inheritance (and also, as always, more performant); especially if you need your type to be copiable. std::function​ std::function is an amazing type! It is basically the strategy pattern embodied in a simple-to-use type! If you need to inject behaviour into a class or if you need to pass a function as a parameter to another function, then std::function is what you need. "},{"title":"Good use cases for inheritance​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#good-use-cases-for-inheritance","content":"You might now be left wondering when using inheritance is a good idea, if reusing code and doing polymorphism are not it. And in fact, good use cases for inheritance are rare. "},{"title":"Interfaces​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#interfaces","content":"This is probably the bigger one. It is OK to inherit1 from a purely abstract class (a.k.a. a class which has no attributes, and only pure virtual methods): class ICamera { public: virtual matrix4x4 view_matrix() const = 0; virtual matrix4x4 projection_matrix() const = 0; }; Copy This is called an interface and is very useful: it allows the client code to be decoupled from any given Camera implementation, and only depend on an interface: void render_scene(const ICamera&amp; camera); // I don't depend on a specific camera implementation // I just need any object which has a `view_matrix()` and a `projection_matrix()` method Copy "},{"title":"CRTP​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#crtp","content":"The Curiously Recurring Template Pattern (CRTP) is a pretty useful implementation trick. For example it allows you to add behaviour to a class easily: class Angle : public op::Addable&lt;Angle&gt; // Defines the operators + and += This is much simpler than implementing them yourself, and less error-prone , public op::Scalable&lt;Angle&gt; // Defines Angle * float, float * Angle, and Angle *= float { // . . . }; Copy (This example uses the op library) To learn about the CRTP, check out this blog post. "},{"title":"Going further​","type":1,"pageTitle":"Composition over Inheritance","url":"lessons/composition-over-inheritance/#going-further","content":"Going Further Mateusz Pusz, Effective replacement of dynamic polymorphism with std::variant (30min) And even multiple inheritance works very well when used with interfaces (and needs to be used in many cases because you want your types to inherit from multiple interfaces)↩ "},{"title":"Dear ImGui","type":0,"sectionRef":"#","url":"lessons/dear-imgui/","content":"Dear ImGui https://youtu.be/vWXrFetSH8w If you want an easy way to get started with Dear ImGui you can use this project template.","keywords":""},{"title":"Deleted functions","type":0,"sectionRef":"#","url":"lessons/deleted-functions/","content":"Deleted functions You can delete functions to prevent them from beeing used. This is mostly used to prevent a type from being copied ; for example std::unique_ptr can't be copied because there can only be one owner of the data, unlike std::shared_ptr. It can be done with the =delete syntax: class MyClass{ //... MyClass(const MyClass&amp;) = delete; // delete the copy constructor MyClass&amp; operator=(const MyClass&amp;) = delete; // delete the copy assignment //... }; Copy","keywords":""},{"title":"Debug vs Release","type":0,"sectionRef":"#","url":"lessons/debug-vs-release/","content":"Debug vs Release","keywords":""},{"title":"Debugger","type":0,"sectionRef":"#","url":"lessons/debugger/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Debugger","url":"lessons/debugger/#brief","content":"Are you tired of printing values to the terminal to know what is going on? Is your program crashing and you don't know where or why? Well the debugger has got your back! A debugger allows you to stop the execution of your program once it reaches a specific point, called a breakpoint, or once a crash occurs. Once hit, you are able to inspect the value of all the variables (and the whole program memory). You can also see which functions were called until this point through the callstack. Finally, you will be able to advance step-by-step into the execution. "},{"title":"How to (with VSCode)​","type":1,"pageTitle":"Debugger","url":"lessons/debugger/#how-to-with-vscode","content":""},{"title":"Prerequisites​","type":1,"pageTitle":"Debugger","url":"lessons/debugger/#prerequisites","content":"You need to use .css-x7zjhw{font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:32px;color:rgba(0, 0, 0, 0.87);background-color:rgba(0, 0, 0, 0.08);border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:default;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;}.css-x7zjhw.Mui-disabled{opacity:0.38;pointer-events:none;}.css-x7zjhw .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-x7zjhw .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-x7zjhw .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-x7zjhw .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-x7zjhw .MuiChip-icon{color:#616161;margin-left:5px;margin-right:-6px;}.css-x7zjhw .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.26);font-size:22px;cursor:pointer;margin:0 5px 0 -6px;}.css-x7zjhw .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-x7zjhw:hover{background-color:rgba(0, 0, 0, 0.12);}.css-x7zjhw.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-x7zjhw:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);} .css-6uhfkt{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:32px;color:rgba(0, 0, 0, 0.87);background-color:rgba(0, 0, 0, 0.08);border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:default;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;}.css-6uhfkt::-moz-focus-inner{border-style:none;}.css-6uhfkt.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-6uhfkt{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-6uhfkt.Mui-disabled{opacity:0.38;pointer-events:none;}.css-6uhfkt .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-6uhfkt .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-6uhfkt .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-6uhfkt .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-6uhfkt .MuiChip-icon{color:#616161;margin-left:5px;margin-right:-6px;}.css-6uhfkt .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.26);font-size:22px;cursor:pointer;margin:0 5px 0 -6px;}.css-6uhfkt .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-6uhfkt:hover{background-color:rgba(0, 0, 0, 0.12);}.css-6uhfkt.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-6uhfkt:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);} cpptools-extension-pack and have a C++ compiler installed on your computer.  "},{"title":"Run your debugger​","type":1,"pageTitle":"Debugger","url":"lessons/debugger/#run-your-debugger","content":"Simply use the &quot;Run and Debug&quot; button in the bottom bar:  "},{"title":"Set breakpoints​","type":1,"pageTitle":"Debugger","url":"lessons/debugger/#set-breakpoints","content":"You can set a breakpoint by clicking on the left of the line, right before the line number, or by pressing F9.  Then, when you run your code with the debugger the program will pause when it hits a breakpoint and the editor will jump to the breakpoint which was hit. You can even place conditional breakpoints if you right-click on the red dot and select &quot;Edit Breakpoint...&quot;. Great if you want the execution to stop only if a variable has a specific value. "},{"title":"Inspect the state of your program​","type":1,"pageTitle":"Debugger","url":"lessons/debugger/#inspect-the-state-of-your-program","content":"Once your program paused on a breakpoint or a crash you can see the value of all variables (by hovering over them or looking in the variables window):  You can also see all the functions that have been called previously (called the call stack) and jump to them:  Finally you can execute the program step by step with the second arrow (step over) or the third one (step into):  "},{"title":"Configure your debugger​","type":1,"pageTitle":"Debugger","url":"lessons/debugger/#configure-your-debugger","content":"If you are using the template project this is already done for you! And if you are using the .css-x7zjhw{font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:32px;color:rgba(0, 0, 0, 0.87);background-color:rgba(0, 0, 0, 0.08);border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:default;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;}.css-x7zjhw.Mui-disabled{opacity:0.38;pointer-events:none;}.css-x7zjhw .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-x7zjhw .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-x7zjhw .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-x7zjhw .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-x7zjhw .MuiChip-icon{color:#616161;margin-left:5px;margin-right:-6px;}.css-x7zjhw .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.26);font-size:22px;cursor:pointer;margin:0 5px 0 -6px;}.css-x7zjhw .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-x7zjhw:hover{background-color:rgba(0, 0, 0, 0.12);}.css-x7zjhw.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-x7zjhw:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);} .css-6uhfkt{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:32px;color:rgba(0, 0, 0, 0.87);background-color:rgba(0, 0, 0, 0.08);border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:default;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;}.css-6uhfkt::-moz-focus-inner{border-style:none;}.css-6uhfkt.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-6uhfkt{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-6uhfkt.Mui-disabled{opacity:0.38;pointer-events:none;}.css-6uhfkt .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-6uhfkt .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-6uhfkt .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-6uhfkt .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-6uhfkt .MuiChip-icon{color:#616161;margin-left:5px;margin-right:-6px;}.css-6uhfkt .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.26);font-size:22px;cursor:pointer;margin:0 5px 0 -6px;}.css-6uhfkt .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-6uhfkt:hover{background-color:rgba(0, 0, 0, 0.12);}.css-6uhfkt.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-6uhfkt:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);} cmake-tools extension you don't even need this launch.json config file.  Yet you might want to set this up by yourself in the future. In order to do so, simply open the &quot;Run and Debug&quot; panel and click on the &quot;Run and Debug&quot; blue button. You now have to select your debugger, first option is for Linux, second is for Windows. Press Default Configuration and it will create a launch.json file under the .vscode folder.  If you want to know the specific details, doc is here. For now you only have to set the &quot;program&quot; field with the path to your executable (so you have to build your program with F7 beforehand). In general with the CMake setup it will be under ${workspaceFolder}/build/bin/Debug/YOURPROGRAM.exe but you should check to be sure. "},{"title":"Design cohesive classes","type":0,"sectionRef":"#","url":"lessons/design-cohesive-classes/","content":"","keywords":""},{"title":"Keep it small​","type":1,"pageTitle":"Design cohesive classes","url":"lessons/design-cohesive-classes/#keep-it-small","content":"Try not to mix concerns inside a single class: it should have only one reason to change. This is known as the Single Responsibility Principle. A good indicator: if none of your methods need to have access to all members at once then you can probably split that class into two or more smaller classes. "},{"title":"Avoid public methods that only use the public API​","type":1,"pageTitle":"Design cohesive classes","url":"lessons/design-cohesive-classes/#avoid-public-methods-that-only-use-the-public-api","content":"If your method only uses public members of the class, then it could be written as a free function: this will make your class simpler, and the overall design more decoupled. See Prefer free functions. tip Public methods are meant to access private members: this is where the encapsulation happens! If they only need public members then you can turn them into free functions. "},{"title":"Avoid private methods​","type":1,"pageTitle":"Design cohesive classes","url":"lessons/design-cohesive-classes/#avoid-private-methods","content":"Private methods are annoying because they are hard to test and they can't be reused outside of the class. Think about it: what is their advantage over a free function? Apart from the fact that they have access to all the members of the class, and therefore they don't need to declare parameters I can't think of anything else3. While it might be quick and easy not to have to declare any parameters (and in some situations where the class remains pretty small this is completely ok), it is often preferable to be clear about the dependencies of each function. So my guideline will be: avoid private member functions, use free functions that take as parameters the things they need. "},{"title":"Going further​","type":1,"pageTitle":"Design cohesive classes","url":"lessons/design-cohesive-classes/#going-further","content":"Going Further Tony Van Eerd, SOLID, Revisited (1h30) Actually they might be used in inheritance hierarchies. But since inheritance hierarchies are a bad practice too, this doesn't quite count 😛↩ "},{"title":"Dependency Injection","type":0,"sectionRef":"#","url":"lessons/dependency-injection/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Dependency Injection","url":"lessons/dependency-injection/#brief","content":"Dependency injection is a fancy way of saying that adding more parameters to your functions is always the right solution to your problems. Managing dependencies between the different parts of your application is probably the biggest challenge as your codebase grows. Thinking about your architecture carefully, and using dependency injection, can help you handle that complexity. "},{"title":"The Singleton attempt​","type":1,"pageTitle":"Dependency Injection","url":"lessons/dependency-injection/#the-singleton-attempt","content":"One tempting solution would be to resort to the Singleton (anti-)pattern: make classes that are static and therefore available everywhere! It has the advantage that you don't need to pass an instance around (which would probably require you to modify the signature of quite a few fonctions). This makes the Singleton a really good solution in the short term. But the Singleton can end up causing a few problems, hence why most people tend to shy away from it: It prevents you from having multiple instances of the same class. Obviously you are a reasonable person and you use a Singleton only for classes that you need only one single instance of... But you often end up realizing that your assumptions were wrong and that you actually need multiple instances. I have a few examples from my personal experience: an history seems like it is unique across the application, until you realize that having separate histories for separate systems is a useful feature. And the argument to rule them all: what if you want to have multiple instances of your application in parallel? Then you can't have any static data because it would be shared accross the instancies of your application. For example think of a workspace in a drawing application: you might want to have multiple drawings open at once, each with it's own layer system, history, etc.It reduces testability: each class that depends on a static class cannot be used outside of the application. This is a big problem for testing (and also for reusing your code!). When testing we usually like to create fake instancies of the dependencies of a class to test that class. For example if you depend on a server, it is nice to make your tests with a mock server rather that the production one! The mock server could for example return a dummy answer when you make a request, whithout even having to make an actual web call. This prevents breaking things in production, or even relying on having a server running. Also you can test different scenarios – like the server beeing down – whithout having to shut down your actual server! This is also why it is nice to depend on interfaces instead of concrete classes. If you depend on an IServer you can then have different test implementations: MockServerRunning, MockServerDown, MockServerLaggy etc.It hides dependencies. Even though it is a pain to write each dependency explicitly in the signature of functions, later down the road you will be happy to be able to see at a glance what is required for a given function (when refactoring for example). It will also be easier to reuse the code later in other projects if the only dependencies are at the function boundary (aka in the signature). "},{"title":"Dependency Injection​","type":1,"pageTitle":"Dependency Injection","url":"lessons/dependency-injection/#dependency-injection","content":""},{"title":"Brief​","type":1,"pageTitle":"Dependency Injection","url":"lessons/dependency-injection/#brief-1","content":"So yes, you should receive all the classes that you depend on as parameters to your functions / methods. Using parameters makes your functions independent of how the outside world is structured, which facilitates change. In the case of a class, receiving the dependencies in the constructor and storing them as members isn't the cleanest solution either, and you should really prefer receiving the dependencies in each method that needs them. This will make clear which parts of your class actually need which dependency. Also if you were to store a reference to the dependency, you would have to make sure that the pointed object outlives the class where the reference is stored; otherwise you would get a dangling reference! For example if your dependency lives in a std::vector, and the vector gets resized at some point, all the references to elements of that vector get invalidated! If you stored one such reference, you are in trouble! On the contrary if you pass the reference to the method each time you call it, you will not notice the change of memory address at all. If you end up with too many arguments to your functions because of all the dependencies, maybe grouping them in a struct can be a good idea. Especially because this probably indicates that those dependencies are related and that there is an abstraction waiting to be discovered and reified into a struct or class. This should be considered carefully though because it could lead to introducing unnecessary dependencies: If a class X needs 4 out of the 5 classes packaged in a struct Y, it can be tempting to make X depend on Y, although it will grab one unnecessary dependency, which is bad. But if you craft your abstractions carefully, everything should be alright and beautiful. To go further, watch Import as an antipattern - Demystifying Dependency Injection in modern Python. "},{"title":"When you have no choice but to store the dependency​","type":1,"pageTitle":"Dependency Injection","url":"lessons/dependency-injection/#when-you-have-no-choice-but-to-store-the-dependency","content":"An interesting exception to the do not store your dependencies rule is if you need your dependency in the destructor of your class (or in an operator like +=): in those cases you cannot pass any arguments because a destructor has no arguments! Therefore you have no other choice but to store the dependency inside the class (or have it global but that would be even worse!). In such cases1, follow the next section's advice and avoid storing &amp;s at all cost! "},{"title":"About storing a reference (&)​","type":1,"pageTitle":"Dependency Injection","url":"lessons/dependency-injection/#about-storing-a-reference-","content":"Never store a &amp;, always store a pointer (*) or a std::reference_wrapper. Storing a reference (&amp;) is a problem because it makes your type non-copy-assignable! That is because when trying to assign to a refence, you are actually assigning to the object behind the reference! You cannot modify where the reference points to after its creation! Let's have an example : class MyClass { public: // Constructor MyClass(const MyDependency&amp; my_dependency) : _my_dependency{my_dependency} // OK: initializes the reference to point to my_dependency {} // Copy Constructor MyClass(const MyClass&amp; o) : _my_dependency{o._my_dependency} // OK: initializes the reference to point to o.my_dependency {} // Copy Assignment operator MyClass&amp; operator=(const MyClass&amp; o) { _my_dependency = o._my_dependency; // Bad! This doesn't change where the reference is pointing to, but instead tries to modify the object that the reference points to! return *this; } private: const MyDependency&amp; _my_dependency; }; Copy Here is a nice article about problems around references by Herb Sutter. "},{"title":"Going further​","type":1,"pageTitle":"Dependency Injection","url":"lessons/dependency-injection/#going-further","content":"Going Further Peter Muldoon, Retiring the Singleton Pattern: Concrete Suggestions for What to use Instead (1h) About the Singleton and alternatives to it Klaus Iglberger, Breaking Dependencies: The SOLID Principles (1h) I met such a case when creating wrapper classes for Vulkan resources: they need a reference to the device to be destroyed, so I had to store a handle to the device in each wrapper class.↩ "},{"title":"CMake","type":0,"sectionRef":"#","url":"lessons/cmake/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#brief","content":"To understand modern CMake you need to understand targets. Basically a target is an executable or a library. You will define a target for your executable and describe its source files, and then you will import the targets for each library you use, and will add those targets as a dependency of your executable. Here is an example: cmake_minimum_required(VERSION 3.8) project(p6-hello-world) add_executable(${PROJECT_NAME} # Creates a target called ${PROJECT_NAME}, a.k.a. p6-hello-world src/main.cpp # And adds its source files: main.cpp and something.cpp src/something.cpp # Note that you don't need to list the header files here (.h / .hpp) ) target_include_directories(${PROJECT_NAME} PRIVATE src) # Directory containing our header files add_subdirectory(p6) # Includes the p6 library; this assumes that you have a folder called p6 at the same level as this CMakeLists.txt file, and that the p6 folder contains a CMakeLists.txt file. target_link_libraries(${PROJECT_NAME} PRIVATE p6::p6) # Adds the target &quot;p6::p6&quot; as a dependency of our target ${PROJECT_NAME}. Unfortunately the command is called target_link_libraries() even though it can be used for other things than just linking; don't get confused! A better name would have been add_dependency() # The name of the target &quot;p6::p6&quot; is up to the library authors. Check out their documentation to know how they called it! # The &quot;::&quot; in the name of the library's target is not mandatory, but library authors often add it because target_link_libraries() can do many different things, and if you make a typo in the name of the target it will ignore it instead of reporting an error. It is only if you have a &quot;::&quot; in the name that target_link_libraries() will know that it can't be anything but a target and will raise an error if the name doesn't actually correspond to a target. Copy And that is all you need for a basic CMakeLists.txt! If all your libraries define a target properly then you don't need anything more to build your project. (If they don't, unfortunately you will have to do their job for them). "},{"title":"CMake tips​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#cmake-tips","content":"Now we will see a few useful things that you can do with CMake: "},{"title":"Setting your C++ version​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#setting-your-c-version","content":"You can ask for a specific version of C++: target_compile_features(${PROJECT_NAME} PRIVATE cxx_std_20) Copy (If you don't you will probably get C++11 by default). You can even ask for finer details with parameters like cxx_variadic_templates. This can be useful to increase the portability of your code a little bit (for example if you need C++11 plus only one little feature from C++14). Don't abuse it though because it can be very tedious to maintain! "},{"title":"GLOB​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#glob","content":"If you don't want to have to list all your .cpp files manually in your CMakeLists.txt you can use file(GLOB_RECURSE MY_SOURCES CONFIGURE_DEPENDS src/*) Copy It will grab the list of all .cpp files in src ant put then in MY_SOURCES. GLOB_RECURSE means that it will also find the files that are in the subdirectories of src. If you only want to find the files at the first level of src you can use GLOB instead. CONFIGURE_DEPENDS means that CMake will check before every build to see if files were added or deleted, and if so it will update accordingly. Without it you would need to manually tell CMake to reconfigure each time you add or remove a file. You can then use that list of files like so: add_executable(${PROJECT_NAME} ${MY_SOURCES}) Copy warning Every CMake expert will tell you that you should never use file(GLOB) or file(GLOB_RECURSE). The reason is always the same and can be found in the official CMake documentation: We do not recommend using GLOB to collect a list of source files from your source tree. If no CMakeLists.txt file changes when a source is added or removed then the generated build system cannot know when to ask CMake to regenerate. The CONFIGURE_DEPENDS flag may not work reliably on all generators, or if a new generator is added in the future that cannot support it, projects using it will be stuck. Even if CONFIGURE_DEPENDS works reliably, there is still a cost to perform the check on every rebuild. I disagree with it though, since to me maintaining a list of my .cpp files in my CMakeLists.txt is more of a hassle than having to refresh CMake manually when I add or remove a file. (And CONFIGURE_DEPENDS makes it even less of a hassle). Now that you have the arguments from both sides, pick your poison. tip If it is hard to add new files to your codebase people will tend to try and avoid it, and will put more things in one single file, which might not be desirable. If you want to encourage people to write many small files, using GLOB_RECURSE might be a good idea 😉 "},{"title":"Adding libraries​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#adding-libraries","content":"In order to make sure that anybody cloning your repository will have all the required libraries to compile your project, it is important to have a way to automatically download them. Submodules are one way of achieving this, but in the case of external libraries that you are not actively writing yourself (which should be most of the cases, especially if you are a beginner programmer), then submodules are a bit annoying and don't bring any value. In that case, CMake offers a better alternative: FetchContent. It will automatically download the libraries when necessary: FetchContent_Declare( # Declare a library: its name and where to find it p6 # Name of the library GIT_REPOSITORY https://github.com/julesfouchy/p6 # Repo of the library GIT_TAG 8346d1e27567815bb9b231cf3ecbfaf1e3bd832a # Exact commit hash that you want to use ) FetchContent_MakeAvailable(p6) # Download the library target_link_libraries(${PROJECT_NAME} PRIVATE p6::p6) # Link the library as usual Copy You can find the hash of a commit on GitHub / GitLab: (by default choosing the latest commit should be fine):  "},{"title":"Enabling warnings​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#enabling-warnings","content":"if (MSVC) target_compile_options(${PROJECT_NAME} PRIVATE /WX /W4) else() target_compile_options(${PROJECT_NAME} PRIVATE -Werror -Wall -Wextra -Wpedantic -pedantic-errors -Wimplicit-fallthrough) endif() Copy /WX and -Werror make your compiler treat warnings as errors, and the other flags enable a lot of useful warnings. tip Warnings are your friends. They exist to protect you from bad practices and bugs. Listen to them! A C++ code that compiles is far from guaranteed to have no bugs! (mostly because of backward compatibility with C). This is why warnings are important! caution If you are writing a library, using warnings as errors can prevent your users from compiling your library. Since the different compilers (and compiler versions) don't generate the same warnings, you might have missed some. You should only enable warnings as errors when you are building the tests of your library, and disable it by default for your users. This is what p6 does: p6/CMakeLists.txt set(WARNINGS_AS_ERRORS_FOR_P6 OFF CACHE BOOL &quot;ON iff you want to treat warnings as errors&quot;) if (WARNINGS_AS_ERRORS_FOR_P6) if(MSVC) target_compile_options(p6 PRIVATE /WX /W4) else() target_compile_options(p6 PRIVATE -Werror -Wall -Wextra -Wpedantic -pedantic-errors -Wconversion -Wsign-conversion) endif() target_include_directories(p6 PUBLIC include) else() target_include_directories(p6 SYSTEM PUBLIC include) # When warnings are disabled, we use the SYSTEM option of target_include_directories: this tells the compiler to ignore any warnings coming from the `include` directory. endif() Copy p6-tests/CMakeLists.txt set(WARNINGS_AS_ERRORS_FOR_P6 ON) add_subdirectory(p6) Copy "},{"title":"Ignoring warnings from external code​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#ignoring-warnings-from-external-code","content":"Warnings are great, but warnings coming from third-party libraries that you did not write are just a nuisance. Luckily, there is a way to disable them! target_include_directories(${PROJECT_NAME} SYSTEM PRIVATE some_lib/include) Copy The SYSTEM option of target_include_directories tells the compiler to ignore any warnings coming from headers in the some_lib/include directory. "},{"title":"Adding #define (compile definitions)​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#adding-define-compile-definitions","content":"You can #define SOMETHING from CMake. This can be useful to propagate information from CMake into your project. For example you can do cmake target_compile_definitions(${PROJECT_NAME} PRIVATE USE_THIS_FEATURE ) Copy C++ #if USE_THIS_FEATURE // Do something #else // Do something else #endif Copy A very good use case is target_compile_definitions(${PROJECT_NAME} PRIVATE $&lt;$&lt;CONFIG:Debug&gt;:DEBUG&gt; ) Copy which defines DEBUG if you are building in debug mode. (This uses a generator expression. It can be read as: &quot;If the CMake CONFIG is Debug, then return DEBUG, otherwise return nothing&quot;). You can then have debug checks in your code that are only compiled in debug mode and totally removed in release: void assert_shader_is_bound(GLint id) { #if DEBUG GLint current_id; glGetIntegerv(GL_CURRENT_PROGRAM, &amp;current_id); assert(current_id == id &amp;&amp; &quot;The shader is not bound&quot;); #endif } Copy You can also give a value to your #define (by default it gets the value 1): cmake target_compile_definitions(${PROJECT_NAME} PRIVATE WINDOW_NAME=\\&quot;Django ${CMAKE_PROJECT_VERSION}\\&quot; ) Copy C++ glfwCreateWindow(1280, 720, WINDOW_NAME, nullptr, nullptr); // Which expands to: glfwCreateWindow(1280, 720, &quot;Django 1.0&quot;, nullptr, nullptr); Copy "},{"title":"Setting the output path​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#setting-the-output-path","content":"By default your executable will end up in build with many other stuff generated by CMake. You can change that with the target property RUNTIME_OUTPUT_DIRECTORY. I personnaly like to do set_target_properties(${PROJECT_NAME} PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/bin/${CMAKE_BUILD_TYPE}) Copy which gives me ├── bin/ │ ├── Debug │ │ ├── myproject.exe // Built in debug mode │ │ └── ... │ └── Release │ ├── myproject.exe // Built in release mode │ └── ... ├── build/ │ ├── random cmake stuff you don't need to care about │ └── ... ├── src/ │ ├── ... │ └── ... └── CMakeLists.txt Copy "},{"title":"Copying files and folders​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#copying-files-and-folders","content":"Very often in projects you need to have files available alongside your executable; it can be images, 3D models, shaders: anything that is not built into your binary but instead loaded at runtime. You will have those files somewhere in your sources, but when you produce an executable and send it to your friends you must not forget to send the other resource files as well! CMake can help you by automating the process of copying these files to the output folder where your executable is created.  All the files required by CoolLab.exe There is no straight-forward of asking CMake to do it1, but you can use this great library. "},{"title":"Precompiled header​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#precompiled-header","content":"A precompiled header is pretty useful (see Precompiled Header). You can create one with CMake using target_precompile_headers: target_precompile_headers(${PROJECT_NAME} PRIVATE &lt;vector&gt; &lt;string&gt; &lt;memory&gt; &lt;functional&gt; &lt;imgui/imgui.h&gt; &lt;imgui/misc/cpp/imgui_stdlib.h&gt; &lt;Cool/Log/Log.h&gt; ) Copy "},{"title":"CMake for library authors​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#cmake-for-library-authors","content":"As a library, your CMakeLists.txt has one goal: define a target containing all the required information for people to link to your library. Users should only have to do add_subdirectory(libname) target_link_libraries(${PROJECT_NAME} PRIVATE libname::libname) Copy This is possible because a target can store a lot of things: the sources, the include directories, the compile definitions, etc. (this information is known as requirements in the literature). When users call target_link_libraries(${PROJECT_NAME} PRIVATE libname::libname) all this information is propagated to ${PROJECT_NAME} by CMake so that our main target will get the proper includes and so on. If you want to have a look at a real-world example of modern cmake, check out p6 (small library) or Cool (big framework). "},{"title":"add_library()​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#add_library","content":"You create your library's target with add_library(libname) Copy (It is the equivalent of add_executable(exename).) "},{"title":"Use the target_xxx() commands​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#use-the-target_xxx-commands","content":"To set requirements of your library, always use a target_xxx function. They all have alternatives without the target_ prefix, but those functions affect the global state instead of just your target, which is obviously bad! For example if your project uses libA and libB, you don't want libB to see the include directories and settings of libA! These libraries should be completely independent! They are all used like so: target_xxx(target_name PRIVATE additional_parameters ...) Copy You can also use PUBLIC or INTERFACE instead of PRIVATE (see PRIVATE | PUBLIC | INTERFACE). Here are the most important functions: target_include_directories Specifies the location of the include files. For a library I would suggest to put them in a include/libname folder and to do target_include_directories(libname PUBLIC include) so that the include files are accessed with #include &lt;libname/some_file.hpp&gt;. It can also be nice to add a libname.hpp file that includes all the other header files. It allows users to include the whole library at once with #include &lt;libname/libname.hpp&gt;.target_sources Adds source files to the target (appends to the list that was already set with add_library(libname some_file.cpp)). It can be useful for example if you only need some files in some situations: add_library(Cool src/Cool.cpp) if (USE_OPENGL) target_sources(Cool PRIVATE src/OpenGL/opengl.cpp) elseif (USE_VULKAN) target_sources(Cool PRIVATE src/Vulkan/vulkan.cpp) endif() Copy target_link_libraries To add another target as a dependency.target_compile_options We have seen it in Enabling warnings.target_compile_features We have seen it in Setting your C++ version.target_compile_definitions We have seen it in Adding #define (compile definitions).target_precompile_headers We have seen it in Precompiled header. "},{"title":"PRIVATE | PUBLIC | INTERFACE​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#private--public--interface","content":"This is the visibility of the requirements set with target_xxx(). PRIVATE: Only this target will have access to these requirements. When other targets link to this one with target_link_libraries() they will not get the private requirements. For example your warning level should always be private because you do not want to impose it on your dependents: target_compile_options(libname PRIVATE -Werror -Wall) Copy PUBLIC: This target and all of its dependents will be able to access the public requirements. For example if some include directories are used both internaly and by users to access the library, then they should be public: target_include_directories(libname PUBLIC include) Copy Also if you use some other library in your headers, then it will be visible by your users when they include your header, so you need to provide your users with the library: target_link_libraries(Cool PUBLIC glad) Copy INTERFACE: This target will not have access to these requirements but its dependents will. It is a bit peculiar but can be used for example in a header-only library: the library itself does not need to see the include directory (since there is no source files at all to build), but the dependents do: target_include_directories(my-header-only-lib INTERFACE include) Copy This can also be used if the user-facing headers are different from the private ones (e.g. if you have many headers but only want users to see a libname.hpp header that includes all the other ones): target_include_directories(libname INTERFACE include) # The include folder is only used by users and only contains libname.hpp target_include_directories(libname PRIVATE src) # All the headers that we use internally are in src (alongside the .cpp) Copy tip Try to keep things private as much as possible! Don't pollute others for no reason. "},{"title":"Add an alias containing \"::\"​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#add-an-alias-containing-","content":"add_library(p6) add_library(p6::p6 ALIAS p6) Copy People care about having a name with :: because target_link_libraries() can do many different things and if you make a typo in the name of the target it will ignore it instead of reporting an error. It is only if you have a :: in the name that target_link_libraries() will know that it can't be anything but a target and will raise an error if the name doesn't actually correspond to a target. As far as the alias name goes, people have different conventions like p6::p6, p6::core etc. Pick one that you like. "},{"title":"Going further​","type":1,"pageTitle":"CMake","url":"lessons/cmake/#going-further","content":"Going Further Stephen Kelly, Embracing Modern CMake (1h) Mathieu Ropert, Using Modern CMake Patterns to Enforce a Good Modular Design (1h) Henry Schreiner, Modern CMake (short online book) Jason Turner, C++ Weekly - Ep 208 - The Ultimate CMake / C++ Quick Start (30min) The default functions available in CMake don't quite do what we want. They copy the files only once, when the CMakeLists.txt file is run. They won't re-copy them automatically whenever they change.↩ "},{"title":"Designated Initializers","type":0,"sectionRef":"#","url":"lessons/designated_initializers/","content":"Designated Initializers","keywords":""},{"title":"Documentation","type":0,"sectionRef":"#","url":"lessons/documentation/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Documentation","url":"lessons/documentation/#brief","content":"Documenting is an essential part of building a big project. Without it your library would be very hard to use, and your code very hard to understand and maintain. You don't necessarily need to do all the things I will advise here, but the more the better. The most important thing is to have a little description of each function / type and how to use them. This is something that you should do as you write your code because if you don't you are never gonna come back to do it later. Once you have more time and are serious about creating a great library that will be used by many, take the time to write tutorials and examples too. "},{"title":"Inline documentation​","type":1,"pageTitle":"Documentation","url":"lessons/documentation/#inline-documentation","content":"Each function and type should have a little description if there is anything special that the users need to know: /// Returns a random int between min (included) and max (included) int rand(int min, int max); Copy Here it is great to indicate whether the min and max bounds are included or excluded. I am not a fan of &quot;automatic&quot; documentation where you feel the need to add a description to every parameter. Only do it if you have something meaningful to say about that parameter! Otherwise I much prefer a simple sentence that explains the function and its parameters all at once. Also, don't just paraphrase the implementation. Bad, this is very redondant /** * @brief Computes the average of a and b. * * @param a The first number that you are gonna take the average of. * @param b The second number that you are gonna take the average of. * @return float The average of a and b. */ float average(float a, float b); Copy Good, much easier to read /** * @brief Computes the average of a and b. */ float average(float a, float b); Copy Even better. In that case I don't think the documentation was adding anything that the name didn't already explain float average(float a, float b); Copy Very good too. Here we are adding some information that might be interesting to the user /// Computes the average of a and b. /// The order of the parameters doesn't matter (i.e. average(10, 5) == average(5, 10)). float average(float a, float b); Copy Giving examples is the best way of making the usage of your function clear! Sometimes it can replace a long sentence very effectively. Ideally the example code should be compilable as-is, with no hidden includes. It also allows you to write some script that grabs all your examples and tries to run them. This way you can reuse your examples as tests for your code, and also make sure your examples are always accurate! "},{"title":"Tutorials and examples​","type":1,"pageTitle":"Documentation","url":"lessons/documentation/#tutorials-and-examples","content":"Having a description of each small element is not enough! You also need to show the bigger picture to your users to help them discover and understand the library. Here is an example of a great tutorial from the Lager library. "},{"title":"Using Doxygen​","type":1,"pageTitle":"Documentation","url":"lessons/documentation/#using-doxygen","content":"Doxygen is the reference tool for C++ projects that want to generate a website from their inline documentation. It has one drawback though: the sites it generates are ugly. You can get around that by using another tool to complement Doxygen, like Sphinx: here is a nice tutorial. "},{"title":"Internal documentation for the maintainers of the library​","type":1,"pageTitle":"Documentation","url":"lessons/documentation/#internal-documentation-for-the-maintainers-of-the-library","content":"This kind of documentation is very different from documenting your API. It talks to developpers who will read and modify the internal code. It aims to help them understand the architecture, the reasons the code looks the way it does, and how to change it. tip Tell a story in your documentation: how do the different components work together? Once you finish implementing a piece of code you should explain your intentions, the alternatives you considered and the reasons that made you choose this particular implementation. Don't be shy, talk a lot, and leave a trace for others.  Here is how I like to do it: Each folder corresponds to a module of the library and has its own ReadMe that explains everything about that module. You can read such a ReadMe here. This is great to make sure people understand why the code is the way it is, don't reintroduce bugs you already fixed, etc. Even if you are unsure or not confident about your design, say it! It will help future developers have no remorse rewriting your code and be confident there isn't some important thing they are missing and that made you write the code the way you did. "},{"title":"Going further​","type":1,"pageTitle":"Documentation","url":"lessons/documentation/#going-further","content":"Going Further Christopher Di Bella &amp; Sy Brand, Documentation in the Era of Concepts and Ranges (1h) Good advice on what to put in your documentation Timothy Daly, Literate Programming in the Large (40min) About internal documentation "},{"title":"Don't overfocus on performance","type":0,"sectionRef":"#","url":"lessons/dont-overfocus-on-performance/","content":"Don't overfocus on performance Because most applications don't really need performance, and correctness is their main concern. Often, the compute-heavy parts are handled by libraries and you don't need to worry about that. If the code that you write doesn't weigh much in the performance scale, don't waste time optimizing it, or worse, don't optimize it at the expense of readability / maintainability ! Sometimes you have to not be obsessed with performance and have a critical eye on wheter this performance matters. Saving 1 nanosecond every second doesn't matter to anyone! (accept maybe in high-frequency trading) Know your environment and your performance requirements, and don't push it further than you need.","keywords":""},{"title":"Error Handling","type":0,"sectionRef":"#","url":"lessons/error-handling/","content":"","keywords":""},{"title":"Exceptions​","type":1,"pageTitle":"Error Handling","url":"lessons/error-handling/#exceptions","content":"Despite their bad reputations, they are actually pretty good and you should consider using them. Here is a very nice paper by Bjarne Stroustrup defending them : http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1947r0.pdf(answering to a discussion opened by https://www.youtube.com/watch?v=GC4cp4U2f2E) "},{"title":"for","type":0,"sectionRef":"#","url":"lessons/for/","content":"for","keywords":""},{"title":"friend","type":0,"sectionRef":"#","url":"lessons/friend/","content":"friend There are very few good reasons to use friend. The only one I can think of is when you are forced, for implementation reasons, to split something into two classes but conceptually it really is one united block. For example, when implementing the state pattern : you have a class X that holds a state S. Although S needs to be a seperate class in order to have different implementations and be changed at runtime, it really is part of X and should be allowed to access it's internals like no one else. Even in that case, you should first wonder wether it wouldn't make sense to put in your public interface all the things that S needs. If the answer is now, then maybe you have a use case for friend. What really bothers me with friend is that it is all or nothing. I wish I could specify that only one given method will be usable by a specific class : &quot;this method is not part of the public API, but it can be used by this one class who knows how to handle it&quot;. With the current friend, all friends suddenly have access to all methods and members. (Maybe this problem is lessened when the Single Responsibility Principle is strictly followed and each class really is an all or nothing package (since there is only one thing in the package), but still I don't like the fact the friends can access member variables) =&gt; Useless since C++20 and modules, which allow us a much finer grain control over visibility PassKey idiom","keywords":""},{"title":"Functional programming","type":0,"sectionRef":"#","url":"lessons/functional-programming/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Functional programming","url":"lessons/functional-programming/#brief","content":"Functional programming is an important paradigm. A lot of very good techniques have emerged from this field and have been incorporated in many languages, including C++. std::optional, std::variant, std::transform and many others are inherited1 from Functional Programming. "},{"title":"Going further​","type":1,"pageTitle":"Functional programming","url":"lessons/functional-programming/#going-further","content":"Going Further Scott Wlaschin, The Power of Composition (1h) A sweet intro to some functional concepts Sy Brand, Building an Intuition for Composition (1h) Gabriel Lebec, Fundamentals of Lambda Calculus &amp; Functional Programming in JavaScript (1h) The theory behind functional programming Scott Wlaschin, The Functional Programmer's Toolkit (1h) Mark Seemann, Functional architecture - The pits of success (1h) Richard Feldman, Why Isn't Functional Programming the Norm? (45min) Scott Wlaschin, Functional Design Patterns (1h) Notice the pun 😉↩ "},{"title":"Formatter","type":0,"sectionRef":"#","url":"lessons/formatting-tool/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Formatter","url":"lessons/formatting-tool/#brief","content":"Tools can format your code automatically: fix indentation, add spaces consistently, put curly braces where you want them, etc.It saves a lot of time because it means you don't have to worry about it and do it manually! Also, it ensures a consistency in style across the whole codebase and all the developers. "},{"title":"Details​","type":1,"pageTitle":"Formatter","url":"lessons/formatting-tool/#details","content":"For C++, Clang format is the most popular one and I would recommend it. Here is how to set it up: First you need to have clangd set upThen go to your VSCode settings and: Set Default Formatter to clangdEnable Format on Save You will also need to put a configuration file named .clang-format at the root of your project to specify how the formatting should be done. You can use this great website to configure it. Or if you don't want to spend too many time tweaking it yourself, you can use mine: https://github.com/CoolLibs/tooling/blob/main/.clang-format. tip Note that in some very specific cases you can disable clang-format locally to use some non-standard formatting, using these special comments: // clang-format off void on_mouse_move (Camera&amp; camera, glm::vec2 const&amp; delta) { std::visit([&amp;](auto&amp;&amp; state) { state.on_mouse_move (*this, camera, delta); }, _state); } void on_wheel_down (Camera&amp; camera, int mods) { std::visit([&amp;](auto&amp;&amp; state) { state.on_wheel_down (*this, camera, mods); }, _state); } void on_wheel_up (Camera&amp; camera) { std::visit([&amp;](auto&amp;&amp; state) { state.on_wheel_up (*this, camera); }, _state); } void on_wheel_scroll(Camera&amp; camera, float dl) { std::visit([&amp;](auto&amp;&amp; state) { state.on_wheel_scroll(*this, camera, dl); }, _state); } // clang-format on Copy "},{"title":"Functions","type":0,"sectionRef":"#","url":"lessons/functions/","content":"Functions","keywords":""},{"title":"DRY: Don't repeat yourself","type":0,"sectionRef":"#","url":"lessons/dry-dont-repeat-yourself/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"DRY: Don't repeat yourself","url":"lessons/dry-dont-repeat-yourself/#brief","content":"In software development we try to avoid duplications. This helps us maintain our code because the important stuff happens in only one place and we don't have to chase the duplicated code around in our codebase when we want to make a change. There are many ways to avoid duplications: Use a loop or an algorithm, when you want to do the same thing multiple times in a row.Use a function, when you want to do the same thing in different places.Use a template, when you want to do the same thing but for different types.Use a struct or a class, when you want to use the same group of data in different places.Use a using declaration, e.g. using Board = std::array&lt;std::array&lt;boardTile, 3&gt;, 3&gt;.Use auto, when the type is already declared in the expression; e.g. std::unique_ptr&lt;MyClass&gt; ptr = std::make_unique&lt;MyClass&gt;(); vs auto ptr = std::make_unique&lt;MyClass&gt;();.Use a macro, (😬1) when you can't use any of the above methods, and have the courage to write and maintain some ugly macro-based code. (Honestly I believe that in most cases duplications are less of an evil than complicated metaprogramming based on macros, so I wouldn't recommend going down the route of macros most of the time). If you really need macros to do complicated things, take a look at a library like Boost.Hana.Use a Python script to generate repetitive parts of your C++ code. This can often be a better solution than macros because the generated code is clean and readable, and therefore easy to debug. Arguably having parts of your C++ code as strings in a Python script can be annoying too, but you have to pick your poison. I would recommend to generate the bits of code you need in separate files, and then include those files where you need them in your C++ code. It will be simpler than having code injected directly by the script in the middle of a regular source file; you can just generate the whole file from scratch each time you run the script. Example: Python script, generated file, C++ file using the generated file. This uses this little helper script I wrote. Tip Code duplication doesn't mean textual duplication, but knowledge duplication. For example, this is not violating DRY even though the text is the same in two places: bool age_is_valid(int age) { return 0 &lt; age &amp;&amp; age &lt; 18; } bool order_is_valid(int amount) { return 0 &lt; amount &amp;&amp; amount &lt; 18; } Copy It is feasible that we will need to change order_is_valid while keeping age_is_valid the same, and it wouldn't be practical to do if the code had been refactored away. In this example the duplication is a coincidence, not a fondamental property of our domain model. See also: Tony Van Eerd, SOLID, Revisited (6min). tip To know if you are violating DRY, ask yourself: &quot;If I change this bit of code, would it be a bug to forget to change that other bit of code?&quot; If the answer is yes, then you are not following the DRY principle. tip You should avoid duplicating implementation, but you are free to duplicate intention because it is way less likely to have to change. (And also it is the atomic element of code so you can't really refactor it away anyways). tip Introducing the wrong abstraction is way worse than introducing duplication. "},{"title":"Going further​","type":1,"pageTitle":"DRY: Don't repeat yourself","url":"lessons/dry-dont-repeat-yourself/#going-further","content":"Going Further DRY - The Evils of Duplication, Chapter 2 of The Pragmatic Programmer (10min, I can lend you the book) Unfortunately there are still some (very rare) use cases for macros. Hopefully those will disappear once we get reflection and proper metaprogramming in the language, which should come in C++26 or C++29.↩ "},{"title":"Enums","type":0,"sectionRef":"#","url":"lessons/enums/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Enums","url":"lessons/enums/#brief","content":"If you are used to using integer constants (or worse, a long list of booleans) to express different possible situations, then don't! Enums are meant to do exactly that and are way clearer to read! // Bad, you need comments to indicate what the numbers mean! void Character::move(int direction) { switch(direction) { case 0: // North /*...*/ case 1: // East /*...*/ case 2: // South /*...*/ case 3: // West /*...*/ default: /*...*/ } } Copy // Good, the meaning is incorporated in the names of the enum and its values! enum class Direction { North, East, South, West, }; void Character::move(Direction direction) { switch (direction) { case Direction::North: /*...*/ case Direction::East: /*...*/ case Direction::South: /*...*/ case Direction::West: /*...*/ default: /*...*/ } } Copy  "},{"title":"Use enum class, not enum​","type":1,"pageTitle":"Enums","url":"lessons/enums/#use-enum-class-not-enum","content":"enum class was introduced in C++ as a better version of the enum from C. An enum class doesn't allow implicit conversion with ints and other enums, and gives a proper namespace to your values! Bad, there is no type checking that ensures we use the right enum enum Direction { Left, Right, Up, Down }; enum CardinalDirection { North, East, South, West }; void move(CardinalDirection direction); move(Left); // Bad, this compiles but doesn't do what we want! It will move North! Copy Bad, this doesn't compile because we are defining two Ok values in the global namespace enum FilesystemError { Ok, // Should be renamed to fs_Ok to avoid conflicting with the other `Ok` ErrorNoPermission, // etc. } enum DatabaseError { Ok, // Should be renamed to db_Ok to avoid conflicting with the other `Ok` ErrorConnectionLost, // etc. } /// /// This is equivalent to defining integer constants in the global namespace: /// static constexpr int Ok = 0; static constexpr int ErrorNoPermission = 1; static constexpr int Ok = 0; // Bad, conflicts with the first Ok static constexpr int ErrorConnectionLost = 1; Copy All of these problems disappear with enum class: Good, the type checking makes sure we use the right enum enum class Direction { Left, Right, Up, Down }; enum class CardinalDirection { North, East, South, West }; void move(CardinalDirection direction); move(Direction::Left); // Good, this doesn't compile and gives us a clear error message Copy Good, this works just fine and we don't need to give weird prefixes to our enum values enum class FilesystemError { Ok, ErrorNoPermission, // etc. } enum class DatabaseError { Ok, ErrorConnectionLost, // etc. } Copy "},{"title":"using enum​","type":1,"pageTitle":"Enums","url":"lessons/enums/#using-enum","content":"Since C++20 you can have a nicer syntax: using enum allows you to skip the enum name in all your switch cases: void Character::move(Direction direction) { using enum Direction; switch (direction) { case North: // More readable than `Direction::North`. We already know that we are dealing with Directions. /*...*/ case East: /*...*/ case South: /*...*/ case West: /*...*/ default: /*...*/ } } Copy "},{"title":"Git Pull Requests","type":0,"sectionRef":"#","url":"lessons/git-pull-request/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Git Pull Requests","url":"lessons/git-pull-request/#brief","content":"Sometimes you want to contribute to an open-source project but you don't have the right to commit directly on that repo. That's normal and you can still contribute via pull requests (abbreviated as PR) (also known as merge requests on GitLab). "},{"title":"How to​","type":1,"pageTitle":"Git Pull Requests","url":"lessons/git-pull-request/#how-to","content":""},{"title":"Fork​","type":1,"pageTitle":"Git Pull Requests","url":"lessons/git-pull-request/#fork","content":"You will have to fork the repository: this will make a copy of this repository under your profile, so that you will be able to commit on that copied repo. Once you have done your commits, you can ask to merge them into the original repo. It will be up to the maintainers of the repo to decide if they want to accept your pull request. Sometimes they will ask you to tweak or improve a few things before accepting your commits.  "},{"title":"Make a dedicated branch​","type":1,"pageTitle":"Git Pull Requests","url":"lessons/git-pull-request/#make-a-dedicated-branch","content":"Every commit you make, even after the pull request is created, will still be included in the PR. So you should make a branch dedicated to that pull request and only commit on that branch the things you want to be included in the PR. Then you can keep working on another branch if you want to modify that repo further, and it won't disturb the PR. "},{"title":"Write a nice message​","type":1,"pageTitle":"Git Pull Requests","url":"lessons/git-pull-request/#write-a-nice-message","content":"When you create your pull request you will be given the opportunity to explain what you changed, and why you changed it. A great explanation will increase your chances of seeing your PR reviewed, and maybe merged.  tip Don't be afraid to point out the areas where you are not sure of your changes. The maintainers will likely be able to help you and indicate how you can improve your pull request before they merge it. To update your pull request after their feedback, simply make new commits on the branch that you submitted for PR and it will update automatically. "},{"title":"Also​","type":1,"pageTitle":"Git Pull Requests","url":"lessons/git-pull-request/#also","content":"Sometimes you will also make pull requests inside the same repo, for example when you want to merge the branch you have been working on into main: instead of merging directly you will create a pull request and ask for the review of some other developers before merging anything. "},{"title":"Git submodules","type":0,"sectionRef":"#","url":"lessons/git-submodules/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Git submodules","url":"lessons/git-submodules/#brief","content":"Submodules are used to link to other repositories: instead of copying a library into your project, you can use a submodule to keep a reference to the original repository. This has several advantages: It doesn't take space on your repo: it is merely a link and people can download it if they want toIt is easier to update: you simply have to pull from the original repositoryYou always know which version of the library you are using: it is written in the Git submoduleIf this is a library that you are developing, you can make the modifications in the project that uses the library, and then push to the repo of the library! This is the biggest selling point to me because it means that you can, in one place, work on the library and the project that uses it. It feels like you have one repo even though there are actually two and one of them can be shared across many projects. "},{"title":"Adding a submodule​","type":1,"pageTitle":"Git submodules","url":"lessons/git-submodules/#adding-a-submodule","content":"With GitKraken you can simply click the Add submodule button and then specify the url of the repo and the folder where you want to clone the submodule:  With the command line you can do: git submodule add https://github.com/url/to/the/repo folder/where/to/clone git submodule update --init --recursive Copy "},{"title":"Cloning a project that uses a submodule​","type":1,"pageTitle":"Git submodules","url":"lessons/git-submodules/#cloning-a-project-that-uses-a-submodule","content":"It doesn't work really well with GitKraken so I recommend to do that step with the command line: git clone --recursive https://github.com/url/to/the/repo Copy If you forget to use that --recursive flag, the submodules won't be cloned. To fix that you can always do: git submodule update --init --recursive Copy "},{"title":"if","type":0,"sectionRef":"#","url":"lessons/if/","content":"if ","keywords":""},{"title":"#if defined()","type":0,"sectionRef":"#","url":"lessons/if-defined/","content":"#if defined() #if defined(SOMETHING) offers more flexibility than #ifdef SOMETHING. For example you can use negation, and and or : #if defined(SOMETHING) &amp;&amp; !defined(SOMETHING_ELSE) You can also it with #elif : #if defined(MACRO1) // ... #elif defined(MACRO2) // ... #elif defined(MACRO3) // ... #else // ... #endif Copy","keywords":""},{"title":"Immediately Invoked Function","type":0,"sectionRef":"#","url":"lessons/immediately-invoked-function/","content":"Immediately Invoked Function","keywords":""},{"title":"Compiler","type":0,"sectionRef":"#","url":"lessons/install-a-compiler/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Compiler","url":"lessons/install-a-compiler/#brief","content":"A compiler is a program that takes your C++ code and creates an executable out of it. Needless to say that it is quite important to have as a C++ developer. "},{"title":"Installation​","type":1,"pageTitle":"Compiler","url":"lessons/install-a-compiler/#installation","content":"WindowsLinuxMac You will find all the explanations you need here (NB: you only need to follow the Prerequisites section). Then install CMake: go here and download and run the Windows x64 Installer. "},{"title":"Inheritance","type":0,"sectionRef":"#","url":"lessons/inheritance/","content":"Inheritance ","keywords":""},{"title":"Git","type":0,"sectionRef":"#","url":"lessons/git/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Git","url":"lessons/git/#brief","content":"git is probably the most important tool of all in your programmer toolbelt! It is a software which is able to handle a giant history of all the changes you ever made to your code. It is very powerful to work with other developers and split your tasks.1 "},{"title":"Why bother?​","type":1,"pageTitle":"Git","url":"lessons/git/#why-bother","content":"There are a few reasons to use git: revert: Go back in time to a working state if you broke something.checkout: Check how the project was at a given date.commit: Be able to work step-by-step by grouping your changes with a description.blame: Be able to know when a line of code was added, and by whom.push: Have a copy of your code on a server so that other developers can get it.pull: Get changes made by other developers.  "},{"title":"Good practices​","type":1,"pageTitle":"Git","url":"lessons/git/#good-practices","content":""},{"title":"Small commits​","type":1,"pageTitle":"Git","url":"lessons/git/#small-commits","content":"Guideline As soon as you have made some progress and the code compiles, make a commit! Try to avoid putting unrelated changes in the same commit: split them over several commits. "},{"title":"Clear messages and descriptions​","type":1,"pageTitle":"Git","url":"lessons/git/#clear-messages-and-descriptions","content":"Guideline Don't be lazy, write actual sentences without stripping words! In the description, explain why you are making the change. Be clear about which part of the code is affected by the changes. I (and others) like to put this inside [ ] at the beginning of the message. It is great to distinguish different types of commit by starting the message with a keyword: Add: adds a new feature / class / function.Update: improves / changes an existing feature / class / function.Fix: fixes a bug.etc. You can also use 😎 Gitmoji 😎, a standard set of emojis to indicate the kind of commit you are making. Here are some example messages I would write: ✨ [guess_the_number] Add get_int_from_user() Copy ♻️ [CMake] Modernize set(EXECUTABLE_OUTPUT_PATH ...) Copy 🐛 [hangman] Fix missing include Copy ♻️ [board] Start using BoardSize instead of int Copy "},{"title":"Don't commit broken code​","type":1,"pageTitle":"Git","url":"lessons/git/#dont-commit-broken-code","content":"Guideline Always make sure the code compiles before commiting it! This can especially happen after a merge or a conflict resolution: so please check that the code is still working before commiting the resolved conflict! "},{"title":"Double check​","type":1,"pageTitle":"Git","url":"lessons/git/#double-check","content":"Guideline Read all your changes before commiting them! It will make sure you don't commit temporary debug code (as I have done way too many times), and it is a good opportunity to review all your changes and make sure you are happy with them. It is also a good opportunity to make sure you are not commiting files you are not suposed to, like your build folder. TIP: Using a graphical interface will greatly help you in that task. "},{"title":"Using a graphical interface​","type":1,"pageTitle":"Git","url":"lessons/git/#using-a-graphical-interface","content":"There are a lot of apps that make the steps of the next sections easier to do and monitor. I would recommend GitKraken for the job. It is free to use for public repositories, has a nice interface and a great set of features. They also have a Youtube channel with tons of concise tutorials to get started. NB: Another great git UI is Fork if you are tired of how laggy GitKraken can sometimes be. (But unfortunately it is not available on Linux). "},{"title":".gitignore​","type":1,"pageTitle":"Git","url":"lessons/git/#gitignore","content":"There are a few files that you don't want to commit to your repository. For example all the build files generated by CMake, or the executable that you built for your machine. To tell git to ignore them you simply have to add a file named .gitignore at the root of your repository and list all the files and folders you want to ignore: .gitignore # Build files # bin/ build/ # User settings # .vscode/ # OS-generated files # .DS_Store .DS_Store? ._* .Spotlight-V100 .Trashes ehthumbs.db Thumbs.db Copy If you are using something like GitKraken you can also right-click on the file or folder and select Ignore. "},{"title":"How to use git​","type":1,"pageTitle":"Git","url":"lessons/git/#how-to-use-git","content":""},{"title":"Overview​","type":1,"pageTitle":"Git","url":"lessons/git/#overview","content":"info The steps are presented with the command line so that you get a better understanding of git. Yet we strongly recommend that you use a graphical interface like GitKraken to simplify this for you. The usual setup when you use git is to create a remote depot that is used as a central authority (often this is GitHub, but many other providers exist like GitLab). Authorized developers clone the content on their computer, make modifications, and push their changes back to the depot so that everyone can get it.  It is also possible to work only locally (which is great for a simple test project or exercises). Simply open a command line and type git init and you can skip the &quot;inital setup&quot; from the next section. It is still possible afterwards to publish your local repository to GitHub though. "},{"title":"Initial setup​","type":1,"pageTitle":"Git","url":"lessons/git/#initial-setup","content":"You first need to install git and go through the setup. Then you can go to GitHub, create a new account, and create a new repository (should be a green button on the &quot;Repositories&quot; left panel). Once created, you will be able to clone it on your computer. To do so, open a command line in the folder you want you repository to be in, and run git clone your_repo_url. Replace &quot;your_repo_url&quot; with the one given by GitHub when you click on the green &quot;Code&quot; button.  "},{"title":"Work routine​","type":1,"pageTitle":"Git","url":"lessons/git/#work-routine","content":"There are only a handful of commands that are useful on a day-to-day basis. Here is how it works: After making some changes, you have to select the files that you want to commit to the remote repo. To select all changed files run git add .  When you are happy with your changes, you can save them in a group that will be stored locally. To do so run git commit -m &quot;Place a description of your changes here&quot;.  Then it is time to make you local commit accessible to others via the remote repository. Simply run git push.  In order to get the latest changes from the remote repository it is recommended to frequently run git pull (in particular, always before calling git push). If you work with other developers it is possible that you encounter conflicts if you made changes at the same place in the same files. In this case, check out the section about resolving conflicts.  You might also have heard about branches. This is an advanced git feature, you likely don't need to use it for your first student projects. If you are curious check out the Advanced Git features. "},{"title":"Resolving conflicts​","type":1,"pageTitle":"Git","url":"lessons/git/#resolving-conflicts","content":"A conflict happens when you made changes in the same place as another developer. In this case you will have to use an external tool to compare the changes and merge them into a valid file. GitKraken is a great tool to handle these situations: check out this tutorial to get started. "},{"title":"Going further​","type":1,"pageTitle":"Git","url":"lessons/git/#going-further","content":"TODO Link to Advanced git features NB: There are many other software versioning solutions out there, but git is by far the most popular one.↩ "},{"title":"Iterators","type":0,"sectionRef":"#","url":"lessons/iterators/","content":"Iterators ","keywords":""},{"title":"l-values and r-values","type":0,"sectionRef":"#","url":"lessons/l-values-and-r-values/","content":"l-values and r-values","keywords":""},{"title":"Internet Search","type":0,"sectionRef":"#","url":"lessons/internet/","content":"Internet Search This is part of your day-to-day job. It is extremely important because you can't know everything + this will help you learn how to use the libraries you use A few pieces of advice: Search in englishInclude all the relevant words (e.g. C++, ...) tip ChatGPT might replace googling very soon (now?)","keywords":""},{"title":"Linked lists","type":0,"sectionRef":"#","url":"lessons/linked-list/","content":"Linked lists Linked lists are rarely usefull. All the theoretical advantages in insertion time and what not are actually murdered by the awfull cache coherency that make them actually very slow. The only real I know them is that they never invalidate refercences.","keywords":""},{"title":"Lambda functions","type":0,"sectionRef":"#","url":"lessons/lambda/","content":"Lambda functions","keywords":""},{"title":"IDE","type":0,"sectionRef":"#","url":"lessons/ide/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"IDE","url":"lessons/ide/#brief","content":"An IDE (Integrated Development Environment) is like a text editor, but way more powerful! It has a lot of additional features that will help you write, run and debug your code! I personally use and recommend Visual Studio Code (VSCode for short). "},{"title":"Extensions​","type":1,"pageTitle":"IDE","url":"lessons/ide/#extensions","content":"There are many extensions that can help you! Check out the recommended extensions for your language or discover what other people use. Here are some great extensions for VSCode that I recommend: cpptools-extension-pack: The Basic C++ extensionsBuildOutputColorizer: To colorize the output of the compilation and highlight error messageserrorlens: To see the errors more clearly in the IDEcode-spell-checker: A great spell checkermarkdown-all-in-one: To preview your markdown and get help during edition (e.g. it can automatically generate a table of content)vscode-great-icons: Nice icons for many file types (.cpp, .hpp, CMakeLists.txt, etc.)vsliveshare: This allows you to work remotely with your teammates in one single editor. It is amazing to work together!cmake-language-support-vscode: To provide autocompletion and formatting for CMake "},{"title":"Quick actions​","type":1,"pageTitle":"IDE","url":"lessons/ide/#quick-actions","content":"Below are a few of the most important things that an IDE will help you with; I will demonstrate them using VSCode but rest assured that any other IDE will have the same functionalities. Please note that most of these actions are only available if .css-x7zjhw{font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:32px;color:rgba(0, 0, 0, 0.87);background-color:rgba(0, 0, 0, 0.08);border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:default;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;}.css-x7zjhw.Mui-disabled{opacity:0.38;pointer-events:none;}.css-x7zjhw .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-x7zjhw .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-x7zjhw .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-x7zjhw .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-x7zjhw .MuiChip-icon{color:#616161;margin-left:5px;margin-right:-6px;}.css-x7zjhw .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.26);font-size:22px;cursor:pointer;margin:0 5px 0 -6px;}.css-x7zjhw .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-x7zjhw:hover{background-color:rgba(0, 0, 0, 0.12);}.css-x7zjhw.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-x7zjhw:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);} .css-6uhfkt{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;font-family:&quot;Roboto&quot;,&quot;Helvetica&quot;,&quot;Arial&quot;,sans-serif;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:32px;color:rgba(0, 0, 0, 0.87);background-color:rgba(0, 0, 0, 0.08);border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:default;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;cursor:pointer;}.css-6uhfkt::-moz-focus-inner{border-style:none;}.css-6uhfkt.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-6uhfkt{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-6uhfkt.Mui-disabled{opacity:0.38;pointer-events:none;}.css-6uhfkt .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#616161;font-size:0.75rem;}.css-6uhfkt .MuiChip-avatarColorPrimary{color:#fff;background-color:#1565c0;}.css-6uhfkt .MuiChip-avatarColorSecondary{color:#fff;background-color:#7b1fa2;}.css-6uhfkt .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-6uhfkt .MuiChip-icon{color:#616161;margin-left:5px;margin-right:-6px;}.css-6uhfkt .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.26);font-size:22px;cursor:pointer;margin:0 5px 0 -6px;}.css-6uhfkt .MuiChip-deleteIcon:hover{color:rgba(0, 0, 0, 0.4);}.css-6uhfkt:hover{background-color:rgba(0, 0, 0, 0.12);}.css-6uhfkt.Mui-focusVisible{background-color:rgba(0, 0, 0, 0.2);}.css-6uhfkt:active{box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);} cpptools-extension-pack is installed in your VSCode.  "},{"title":"Rename​","type":1,"pageTitle":"IDE","url":"lessons/ide/#rename","content":"Right-click on any name and choose Rename Symbol (or put your text cursor on a name and use the shortcut F2). It is better than doing a &quot;Find and Replace&quot; because &quot;Rename Symbol&quot; is content-aware; e.g. if you rename a class called &quot;Point&quot; it will not affect another class called &quot;Point2D&quot;.  "},{"title":"Go to definition​","type":1,"pageTitle":"IDE","url":"lessons/ide/#go-to-definition","content":"This will take you directly to the definition of the variable / function / class. This is the functionality I use the most to move around my code. And if you want to stay focused on the portion of code you are currently editing you can also Peek at the definition and it will open a small window inside your current file.  "},{"title":"Go to symbol​","type":1,"pageTitle":"IDE","url":"lessons/ide/#go-to-symbol","content":"This allows you to quickly jump to a method in a file; the shortcut is CTRL + SHIFT + O and then you can type in what you are looking for. It is also super useful to outline the structure of a file.  "},{"title":"Go to file​","type":1,"pageTitle":"IDE","url":"lessons/ide/#go-to-file","content":"If you know which file you want to open it is blazing fast to press CTRL + P and type what you need.  "},{"title":"Switch between .hpp and .cpp​","type":1,"pageTitle":"IDE","url":"lessons/ide/#switch-between-hpp-and-cpp","content":"Use ALT + O to quickly switch between the header and the implementation file. Very useful when you are writing code for a class. "},{"title":"Find all references​","type":1,"pageTitle":"IDE","url":"lessons/ide/#find-all-references","content":"This allows you to find all the places where a symbol is used. Simply right-click on a variable or method and select Find All References to get this panel to open. Just like the Rename Symbol action it is context-aware and is supposed to only return the correct variable (if another one has the same name, it won't show up).  "},{"title":"Search for a word in the current file​","type":1,"pageTitle":"IDE","url":"lessons/ide/#search-for-a-word-in-the-current-file","content":"Useful to find you way around, simply press CTRL + F to open this popup and search what you need. The arrow on the left allows you to rename the occurrences you found, which can be useful.  "},{"title":"Search for a word in the whole project​","type":1,"pageTitle":"IDE","url":"lessons/ide/#search-for-a-word-in-the-whole-project","content":"If you need to find something fast and easy, run CTRL + SHIFT + F, enter the object of desire and press enter. The VSCode search bar is awesome and won't let you down, you can even batch-rename things there! As a side note, it is also great to be able to limit the search to a specific folder, the option is available when you press the three dots on the right.  "},{"title":"Launching the project​","type":1,"pageTitle":"IDE","url":"lessons/ide/#launching-the-project","content":"Once you have the CMake setup done (either by using the template project or by doing it yourself) you can build the project by pressing F7 or run it using CTRL + F5. "},{"title":"Going further​","type":1,"pageTitle":"IDE","url":"lessons/ide/#going-further","content":"TODO link to lesson Master your IDE "},{"title":"Markdown","type":0,"sectionRef":"#","url":"lessons/markdown/","content":"","keywords":""},{"title":"Subtitle​","type":1,"pageTitle":"Markdown","url":"lessons/markdown/#subtitle","content":""},{"title":"Sub-subtitle​","type":1,"pageTitle":"Markdown","url":"lessons/markdown/#sub-subtitle","content":"italic text bold text a link Abulletpointlist tip As you can see the Markdown syntax is very light and doesn't hurt the source text's libility (unlike html). You can learn more about the Markdown syntax here. "},{"title":"Macros","type":0,"sectionRef":"#","url":"lessons/macros/","content":"Macros","keywords":""},{"title":"Make it work, then make it good","type":0,"sectionRef":"#","url":"lessons/make-it-work-then-make-it-good/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Make it work, then make it good","url":"lessons/make-it-work-then-make-it-good/#brief","content":"No matter all the other advice I am gonna give you, always remember this one: If you can't find the &quot;perfect&quot; solution, if you know that there must be a simpler way but can't figure out what it is, then don't worry too much and do what works for you! The most important quality of a piece of code is that it works. All the other advice in the other lessons are just here to help you write working code, and make sure it keeps working over time when you make changes to it or to the code surrounding it. It is completely OK if you do some copy-paste, some duplication, some not-so-good names while you are trying to get something to work. I don't want you to get paralyzed by all the other considerations about clean code. BUT beware! I never said not to care about the quality of your code! Just that this concern should come in a second pass, once you already have a working piece of code. At that point, don't move on to the next feature! Go back to the code you just wrote, inspect it thoroughly, and try to improve it! Refactor duplicated code, split complicated functions into smaller ones, create structs to hold the data that belongs together, etc. Basically, try to apply all the things you will learn in the next lessons. tip Over time you will realize that – as you get used to writing clean code – you will start to write better code even during the first prototyping pass. But until then, don't feel compelled to produce the best code ever in the first pass. "},{"title":"Minimize dependencies","type":0,"sectionRef":"#","url":"lessons/minimize-dependencies/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Minimize dependencies","url":"lessons/minimize-dependencies/#brief","content":"The dependencies of a given class / function are basically all the things that are accessible (visible) to that class / function. And the more things your object can touch, the more complex it is, the more potential for bugs there is, and the harder to reason about the object becomes. That's why you should always try to minimize dependencies. For example, if a render_image() function needs the view matrix of a camera, only pass the matrix, not the whole camera! Also, having less dependencies will make your code easier to change, because a change to the Camera class won't affect the render_image() function if the latter properly declared that it was not actually depending on the camera but only on one matrix. It also helps with reuse (and testing) as several classes that are not necessarily a Camera might have a matrix and might want to use the render_image() function too! Prefering free functions is also one way to reduce dependencies: now the function only depends on the public parts of the class, whereas a method would have depended on the whole class.   tip Here are a few tools you have available to minimize dependencies: Prefer free functions to methodsOnly take as arguments the things you really needWrite small classes and functions... "},{"title":"Measuring performance","type":0,"sectionRef":"#","url":"lessons/measuring-performance/","content":"Measuring performance","keywords":""},{"title":"Master your IDE","type":0,"sectionRef":"#","url":"lessons/master-your-ide/","content":"","keywords":""},{"title":"Learn the shortcuts​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#learn-the-shortcuts","content":"My tip is to try, once in a while, to pick an action that you often need (like deleting a whole line, selecting all the occurences of a word in the text, opening the Settings menu, etc.) and go search for the shortcut (either on the Internet or in the great VS Code shortcut menu (in File-&gt;Preferences-&gt;Keyboard Shortcuts)). And if you don't like the default shortcut, you can always change it! tip Take the time to learn! Next time you say &quot;Oh I wish I knew how to do xxx faster!&quot; take the time to learn how to do it! It will save you a lot of time later down the road! You can also discover shortcuts by watching other people write code. Take the time to ask them what the shortcut is, or go search for it! "},{"title":"Adapt the Settings​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#adapt-the-settings","content":"Take the time to open the Settings menu of your IDE, and read through it! You will discover a lot of the hidden functionalities of your IDE, and you might be able to change its behaviour to better suit your needs! I often feel silly when I discover that the functionality I was dreaming of was actually available, waiting for me to enable it. The same is true for the extensions you use: they can be configured in a lot of different ways, so check out their settings! (For example, did you know that you can tell the CMake extension where your CMakeLists.txt is? It doesn't have to be at the root of your project!) "},{"title":"A few great actions​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#a-few-great-actions","content":"Do you know how to do each of these? If not, try to learn them one by one: "},{"title":"Select multiple occurences of the same word​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#select-multiple-occurences-of-the-same-word","content":""},{"title":"Delete the current line​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#delete-the-current-line","content":""},{"title":"Move the current line up​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#move-the-current-line-up","content":""},{"title":"Duplicate the current line​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#duplicate-the-current-line","content":""},{"title":"Go to a file​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#go-to-a-file","content":"CTRL + P "},{"title":"Switch between a header file and the corresponding .cpp file​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#switch-between-a-header-file-and-the-corresponding-cpp-file","content":""},{"title":"Close all open tabs​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#close-all-open-tabs","content":""},{"title":"Save all open tabs​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#save-all-open-tabs","content":""},{"title":"Launch the project​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#launch-the-project","content":""},{"title":"Build the project​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#build-the-project","content":""},{"title":"Debug the project​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#debug-the-project","content":""},{"title":"Go to definition​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#go-to-definition","content":""},{"title":"Find all occurences​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#find-all-occurences","content":""},{"title":"Search for a word in the current file​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#search-for-a-word-in-the-current-file","content":""},{"title":"Search for a word in the whole project​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#search-for-a-word-in-the-whole-project","content":""},{"title":"Rename​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#rename","content":""},{"title":"Putting multiple cursors at once​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#putting-multiple-cursors-at-once","content":""},{"title":"Opening a new window​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#opening-a-new-window","content":""},{"title":"Opening another project / folder​","type":1,"pageTitle":"Master your IDE","url":"lessons/master-your-ide/#opening-another-project--folder","content":""},{"title":"Multithreading","type":0,"sectionRef":"#","url":"lessons/multithreading/","content":"Multithreading jthread in C++20","keywords":""},{"title":"namespace","type":0,"sectionRef":"#","url":"lessons/namespace/","content":"namespace","keywords":""},{"title":"Operator Overloading","type":0,"sectionRef":"#","url":"lessons/operator-overloading/","content":"Operator Overloading","keywords":""},{"title":"std::optional","type":0,"sectionRef":"#","url":"lessons/optional/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"std::optional","url":"lessons/optional/#brief","content":"   Read this great lesson on std::optional. "},{"title":"Going further​","type":1,"pageTitle":"std::optional","url":"lessons/optional/#going-further","content":"Going Further Ben Deane, Using Types Effectively (1min) "},{"title":"Pointers vs References","type":0,"sectionRef":"#","url":"lessons/pointers-vs-references/","content":"Pointers vs References Pointers can be null Pointers can be repointed https://youtu.be/YnWhqhNdYyk?t=2253","keywords":""},{"title":"Move constructors","type":0,"sectionRef":"#","url":"lessons/move-semantics/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Move constructors","url":"lessons/move-semantics/#brief","content":"    You all know what copying an object means. But did you know that we can do better in some circumstances? move is an optimization of copy. For example consider: std::vector&lt;int&gt; create_n_integers(int n) { std::vector v; for (int i = 0; i &lt; n; ++i) { v.push_back(n); } return v; } std::vector&lt;int&gt; my_vector = create_n_integers(10000000); Copy It might look like we are doing a copy: a vector is created inside create_n_integers and then when we do my_vector = create_n_integers(10000000) we copy the vector from create_n_integers into my_vector. And you know that a vector can be big and therefore its copy can be expensive! All of that is true, but the above code is still perfectly fine. This is because the compiler knows that there is no need to do a copy and that it can do a move instead: same effect, but faster. So, what exactly is a move? The idea is that when an object is about to be destroyed, there is no need to keep that object intact; our &quot;copy&quot; operation is therefore allowed to modify it. That &quot;destructive copy&quot; is called a move. Why would modifying the &quot;copied&quot; object be useful? Let's take the example of a std::vector&lt;int&gt; v1. A vector is implemented as a pointer to an array of elements on the heap. If we ask for a copy of the vector (std::vector&lt;int&gt; v2 = v1;) then it has to copy all the elements of the array into a new array, because we want v1 and v2 to be independent objects. If we were to only copy the pointer, then v1 and v2 would point to the same array and modifying v1 would also affect v2, which would be very confusing and impractical. Therefore making a copy of a big vector is slow because each of the (possibly many) elements of the vector has to be copied. But if we know that v1 is no longer used, then we don't care if it points to the same array as v2! There is no way of touching v1 and accidentaly modifying v2! In that case we can simply copy the pointer and save a lot of time. tip This is the power of move: the compiler optimizes your copy when it knows that you won't see the difference between a copy and a move. So, do you need to think about move all the time? Luckily, no! It will happen automatically in places where it can. Just remember that having a function that returns a vector by value is not a bad thing because the copy will be optimized into a move, which is cheap. Another explanation The Cherno, Move Semantics in C++ (13min) "},{"title":"Implementing move for your own classes​","type":1,"pageTitle":"Move constructors","url":"lessons/move-semantics/#implementing-move-for-your-own-classes","content":"For most of your classes a move constructor will be defined automatically (just like the copy constructor) and you have nothing to do. The only time when you need to implement move yourself is if your class has an explicitly defined destructor or copy constructor (see The Rule of 5). This should be rare because if all the members of your class already have move and destruction defined, then your class will get a default move and destructor that will do the right thing and everything will be fine. The only case where you would need to define destruction and move is when you manage a resource like a pointer, an object from a C api that needs to be freed, etc. Note that in the case of a pointer the problem is already solved by std::unique_ptr and std::shared_ptr. Please don't allocate your pointers with raw new and don't add destructors to your classes just to manage the pointers that you allocated. Use std::unique_ptr instead and you won't even need to think about destructors and move constructors. If you ever need to create a wrapper similar to a std::unique_ptr for some resource (like an OpenGL id), here is how to do it: class UniqueBuffer { public: UniqueBuffer() { glGenBuffers(1, &amp;_id); // Do whatever you need to create the resource } ~UniqueBuffer() { glDeleteBuffers(1, &amp;_id); // Do whatever you need to delete the resource } UniqueBuffer(const UniqueBuffer&amp;) = delete; // We disable copying UniqueBuffer&amp; operator=(const UniqueBuffer&amp;) = delete; // We disable copying UniqueBuffer(UniqueBuffer&amp;&amp; other) noexcept // Move constructor : _id{other._id} { other._id = 0; // Make sure that other won't delete the _id we just copied } UniqueBuffer&amp; operator=(UniqueBuffer&amp;&amp; other) noexcept // Move assignment operator { if (this != &amp;other) { // Make sure that we don't do silly things when we try to move an object to itself glDeleteBuffers(1, &amp;_id); // Delete the previous object _id = other._id; // Copy the object other._id = 0; // Make sure that other won't delete the _id we just copied } return *this; // move assignment must return a reference to this, so we do it } GLuint id() const { return _id; } // The getter for the wrapped `_id`. private: GLuint _id; }; Copy Many things to note: We disable copying because we can't simply copy the _id (the copy would refer to the same object as the original, which would be problematic just like in our vector example), and we can't create a copy of the object with glGenBuffers because we have no idea what was stored in that buffer by users (if we were to do a naive copy constructor, then when users ask for a copy they would get a new empty buffer instead of a copy of all the vertex data or whatever that was added to the buffer). Disabling copy can also prevent accidental copies of objects that are not supposed to be copied (e.g. because they are big and the copy would be expensive).We do other._id = 0; when we move. This is because if we don't, then when other gets destroyed it will destroy its _id, which is the same as what our new object is using, which would make it invalid!We do if (this != &amp;other). This is because someone could call v = std::move(v); (in generic code it can happen and it is not that obvious and sometimes you need to do it). In such cases without the check we would do other._id = 0; but since other is ourself we would just lose our _id!The signature for move operations contains UniqueBuffer&amp;&amp;. This &amp;&amp; symbol is called an r-value reference; it is kind of like the usual reference &amp; (called an l-value reference) but it indicates that you are allowed to modify the object and steal its resources. Basically it means that it is okay to move from the object. The move constructor and move assignment are marked noexcept which is EXTREMELY IMPORTANT. If you don't then STL containers like vector will not use your move and will do a copy instead (because it would be problematic if an exception was thrown while a vector is resizing and moving objects to the new location). And since copy is disabled, you will get a nasty compilation error and not be able to store your objects inside vectors! tip Make your wrappers as small as possible. Because if you need to define a move constructor in a big class then you need to tell it to move each member variable, which is tedious and error prone. Plus you will probably need that resource in several classes and you don't want to have to repeat the destruction code in each of them. You can find examples of such wrappers in GL++. "},{"title":"Asking for a move with std::move​","type":1,"pageTitle":"Move constructors","url":"lessons/move-semantics/#asking-for-a-move-with-stdmove","content":"Moves happen automatically: When returning from a functionWhen passing a temporary value to a function (a.k.a. something that was not put in a variable). In f(MyClass{1, 3});, MyClass{1, 3} is not given any name: it is a temporary and will be moved into f instead of being copied. But if you have std::vector&lt;MyClass&gt; v; MyClass my_class{1, 3}; // Maybe do something with my_class // . . . v.push_back(my_class); Copy when passing my_class to push_back it will be copied instead of moved. But let's say that we don't need my_class after the call to push_back: then it would be nice to move my_class into push_back and avoid a copy. We can ask for that by doing v.push_back(std::move(my_class));. This works because push_back is overloaded to accept both normal references (const MyClass&amp;) and r-value references (MyClass&amp;&amp;). caution After calling std::move() on an object, don't use it again! It has been moved away and might not be valid anymore. To learn more on that, check out Beware: Zombies. "},{"title":"Return value optimization (RVO)​","type":1,"pageTitle":"Move constructors","url":"lessons/move-semantics/#return-value-optimization-rvo","content":"Sometimes the compiler can do even better than move. When you are returning an unnamed variable from a function you are guaranteed that there won't even be a move, the variable will be created in place at the call site. This is called RVO and is guaranteed by the standard. std::vector&lt;int&gt; create_some_vector(int x) { int a = x + 1; int b = x * 2; return std::vector&lt;int&gt;{{a, b}}; // RVO applies because we did not give a name to the variable std::vector&lt;int&gt;{{a, b}}, we returned it directly } std::vector&lt;int&gt; v = create_some_vector(2); // No copy nor move. It is the same as doing std::vector&lt;int&gt; v = {2 + 1, 2 * 2}; Copy Compilers can do other optimizations, but RVO is (currently) the only one that is guaranteed. In our first example RVO doesn't apply because we gave a name to the variable that we return (v). But chances are your compiler will still optimize the move away; this is known as NRVO (Named Return Value Optimization). "},{"title":"Going further​","type":1,"pageTitle":"Move constructors","url":"lessons/move-semantics/#going-further","content":"Going Further Titus Winters, Abseil tip (5min) Klaus Iglberger, Back To Basics: The Special Member Functions (1h) Arthur O'Dwyer, Return Value Optimization: Harder Than It Looks (25min) "},{"title":"Precompiled Header","type":0,"sectionRef":"#","url":"lessons/precompiled-header/","content":"Precompiled Header","keywords":""},{"title":"<random>","type":0,"sectionRef":"#","url":"lessons/random/","content":"&lt;random&gt; going further Stephan T. Lavavej, rand() Considered Harmful (30min)","keywords":""},{"title":"Naming","type":0,"sectionRef":"#","url":"lessons/naming/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Naming","url":"lessons/naming/#brief","content":"Naming is very important because this is your first and most powerful tool to communicate with the other developers (and with yourself in the future). It is very important that you pick your names carefuly, take the time to mature your design, and change the names whenever you realize they don't quite describe what your object is or does anymore. tip Take the time to rename whenever you notice a name that is not quite accurate! Use the features of your IDE to make the renaming easy. The greatest names are both consise and descriptive: they encapsulate a concept perfectly and everybody can wrap their head around them easily. The next best thing are names that are long, but still descriptive. The fact that you need a &quot;sentence&quot; to describe your object might indicate that you don't fully understand the abstraction behind it, or that you have a design flaw (maybe your function tries to do several things at once and should be split, or maybe your class has more than one responsibility). Nevertheless it is still a decent name and you can live with it for a while. The last kind of names are the ones that are obscure (or worse, lies); those are inacceptable! tip To help you find good names, imagine yourself explaining to someone what the function does (or even better, actually find someone and explain it to them). Listen to the words that you will naturally say: they will often be a very good name for your function. And even if it is a full sentence, a long name is better than a bad one. tip I could not do a better job than Kevlin Henney already did, so please watch those 10 minutes of his conference, starting at 41:30. Kevlin Henney, Clean Coders Hate What Happens to Your Code When You Use These Enterprise Programming Tricks "},{"title":"Anecdote​","type":1,"pageTitle":"Naming","url":"lessons/naming/#anecdote","content":"Finding the right name sometimes gives you ideas of how to improve your design. For example I wanted a class to hold a width and a height to represent the size of some images. I started calling it RectangleSize to be more generic, but when I realized it was more of an ImageSize it helped me a lot! Because then I added an invariant to that class : width &gt; 0 &amp;&amp; height &gt; 0. This is very useful because most graphics APIs won't accept an empty image anyways and I was doing tests all over the place to make sure that width &gt; 0 &amp;&amp; height &gt; 0. Once I had this invariant for ImageSize I was able to use it safely without checks, since they already took place in the constructor of ImageSize. "},{"title":"Some Guidelines​","type":1,"pageTitle":"Naming","url":"lessons/naming/#some-guidelines","content":"Some of these are extracted from the Unreal Engine Coding Guidelines. "},{"title":"Name your booleans as questions or assertions​","type":1,"pageTitle":"Naming","url":"lessons/naming/#name-your-booleans-as-questions-or-assertions","content":"To make it clear what true and false mean: // Bad, what does true mean? bool CheckTea(Tea tea); // Good, the name makes it clear that true means the tea is fresh bool TeaIsFresh(Tea tea); // Also good bool IsTeaFresh(Tea tea); Copy The assertion version is great because it makes your code read as an actual sentence: if (TeaIsFresh(myTea)). On the other hand the question version is great because the first word (is, has, does, etc.) makes it instantly clear that this is a boolean. "},{"title":"Avoid abbreviations​","type":1,"pageTitle":"Naming","url":"lessons/naming/#avoid-abbreviations","content":"What is obvious to you might not be obvious to everybody. Instead of taking the risk, just take the time to type a few more letters 😉. Only use abbreviations if you are relying on a well established convention, like id for identifier. For example the Bloomberg Coding Standards define a list of allowed abbreviations that everyone should know the meaning of (See Section 3.4.3). // Bad. Can you guess what this stands for? int calc_rev_diff(); // Good, no guessing involved int calculate_revenue_difference(); // Bad (although we have gotten used to it so this is now an OK convention) void mkdir(); // Good, much clearer to everybody, especially to newbies void make_directory(); Copy "},{"title":"Use variables or functions to split complicated statements​","type":1,"pageTitle":"Naming","url":"lessons/naming/#use-variables-or-functions-to-split-complicated-statements","content":"Because it is faster to read than a comment, and can't be outdated: // Bad, difficult to understand if ((Blah-&gt;BlahP-&gt;WindowExists-&gt;Etc &amp;&amp; Stuff) &amp;&amp; !(PlayerExists &amp;&amp; GameStarted &amp;&amp; PlayerStillHasPawn &amp;&amp; IsTuesday()))) { DoSomething(); } // Good, way easier to understand const bool WindowIsValid = Blah-&gt;BlahP-&gt;WindowExists-&gt;Etc &amp;&amp; Stuff; const bool PlayerIsDead = PlayerExists &amp;&amp; GameStarted &amp;&amp; PlayerStillHasPawn &amp;&amp; IsTuesday(); if (WindowIsValid &amp;&amp; !PlayerIsDead) { DoSomething(); } Copy "},{"title":"Going further​","type":1,"pageTitle":"Naming","url":"lessons/naming/#going-further","content":"Going Further Kate Gregory, Naming is Hard: Let's Do Better (1h) "},{"title":"Polymorphism","type":0,"sectionRef":"#","url":"lessons/polymorphism/","content":"","keywords":""},{"title":"Static Polymorphism​","type":1,"pageTitle":"Polymorphism","url":"lessons/polymorphism/#static-polymorphism","content":"Function overloading and templates. https://www.fluentcpp.com/2017/04/28/extract-interface-cpp/ "},{"title":"Dynamic Polymorphism​","type":1,"pageTitle":"Polymorphism","url":"lessons/polymorphism/#dynamic-polymorphism","content":"Base class vs std::variant. When people say why OOP is so great, the biggest (hidden) argument is most often that polymorphism is great. But beware the confusion ! OOP is not the only way of achieving polymorphism ; generic programming with std::variant is an option too. "},{"title":"Going further​","type":1,"pageTitle":"Polymorphism","url":"lessons/polymorphism/#going-further","content":"Going Further Klaus Iglberger, Embrace No Paradigm Programming! (1h) Comparison of different approaches to achieve polymorphism "},{"title":"Prefer free functions","type":0,"sectionRef":"#","url":"lessons/prefer-free-functions/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Prefer free functions","url":"lessons/prefer-free-functions/#brief","content":"info A free function is just a plain old function, i.e. it is not a method, it is not attached to any class. (By the way, methods are often called member functions in C++.) void i_am_a_free_function() { // ... } class Foo { public: void i_am_a_method() // Also known as a &quot;member function&quot; in C++ { // ... } }; Copy tip Free functions help a lot with decoupling, code reuse, testing, etc. The problem with methods is that they depend on the whole class and, if your class is quite large (which it shouldn't but that's a different topic) then you probably have many unnecessary dependencies. It makes it harder to reason about methods at the call site because they could use any information from the class and, if they are not const, modify any member of the class. On the other hand free functions are very clear about their dependencies: it's just the arguments of the function, nothing is hidden. And even if you pass the whole class to the function, at least it can only use the public interface of the class which greatly limits the harm it can do. NB: This doesn't mean that methods are bad or that you should never use them. If you need to encapsulate data and only access it in well defined ways, a method is the way to go. But if something can be done using only the public interface of a class, then a free function is preferable to a member function. Free functions are also very easy to reuse since they are not buried inside a class and have minimal dependencies. tip Check out what David Sankel has to say about this (1 minute, starting at 36:00), as well as the C++ Core Guidelines. "},{"title":"Static functions​","type":1,"pageTitle":"Prefer free functions","url":"lessons/prefer-free-functions/#static-functions","content":"If a free function is only used inside one .cpp file, you don't even need to declare it in the header, you can just mark it static1 and define it in the .cpp: static void i_am_a_helper_free_function() // Note the `static` keyword here. { // ... } void i_am_a_free_function_that_is_declared_in_the_header_and_reused_in_other_files() { i_am_a_helper_free_function(); // I use static helper functions to implement myself. // These functions are not needed by anyone but me so they are marked `static`. // ... } Copy tip Many free functions can be made static and I bet you don't do this often enough. "},{"title":"Going further​","type":1,"pageTitle":"Prefer free functions","url":"lessons/prefer-free-functions/#going-further","content":"Going Further Klaus Iglberger, Free Your Functions! (1h) Scott Meyers, How Non-Member Functions Improve Encapsulation (15min) static ensures that other files cannot see the implementation of your static function. Using static is not required but it is nice to do it. For example if two files define a function with a very common name (e.g. helper()), this will clash and fail to compile if these functions have not been made static, because by default all files have access to ALL the functions that have been defined in ALL the files (unless they are marked static). Disclaimer: static has several meanings in C++, depending on the context. Here we are only talking about its meaning when applied to a free function. (It has a different meaning for methods, and yet another meaning for variables). Refer to the lesson on static for more information.↩ "},{"title":"The Rule of 5","type":0,"sectionRef":"#","url":"lessons/rule-of-5/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"The Rule of 5","url":"lessons/rule-of-5/#brief","content":"The Rule of 5 states that if you write a special member function (a.k.a. a destructor, a copy constructor, a copy assignment, a move constructor or a move assignment), then you need to write all 5 of them. They will not be generated by the compiler because if you define one explicitly this probably means that the implementation that the compiler would have defined by default is not good for any of them. An example of that is an object containing a raw owning pointer: it needs to be deleted, but also when you make a copy of it you want to copy the pointed object, not the pointer, in order to preserve value semantics. If you were to copy only the pointer then the copied object would point to the same thing as the original object, they would not be independent copies. Also when the first one would be deleted it would delete the pointer that the other object also uses, and you will get a segmentation fault somewhere because the second object is still alive but the pointer it holds has already been destroyed by someone else. If you have to implement special member functions explicitly, try to make the class as small as possible. You most likely have only one member of your class that requires the destructor / copy. Then, move that member into its own class that implements the rule of 5, and in your main class use that wrapper class and let the compiler generate the destructor / move / copy. It will prevent you from forgetting to copy a member in your copy / move, or something silly of that kind. tip C.20: If you can avoid defining default operations, do. Most classes shouldn't have explicit special member functions: This is known as the Rule of 0. Those rare ones that need the Rule of 5 should be kept at a minimal size: only one member variable. "},{"title":"Range-based for loop","type":0,"sectionRef":"#","url":"lessons/range-based-for-loop/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Range-based for loop","url":"lessons/range-based-for-loop/#brief","content":"If you want to go over each element of a container v once (which the case of most for loops) you can write: // If you want to modify the elements of v: for (auto&amp; x : v) { // ... } Copy // If you don't want to modify the elements of v, and your type is costly to copy: for (const auto&amp; x : v) { // ... } Copy // If you don't want to modify the elements of v, and your type is cheap to copy: for (auto x : v) { // ... } Copy This helps you express your intent more clearly! It guarantees that you are not modifying the index in the body of the loop to make nasty things and change the iteration process. Having this guarantee helps people reason about your code, and this is very important! const std::vector v = {3, 1, 17, 8}; for (size_t i = 0; i &lt; v.size(); ++i) { // Long body // Might do i++ somewhere // This is hard to debug } Copy "},{"title":"References","type":0,"sectionRef":"#","url":"lessons/references/","content":"References","keywords":""},{"title":"Scope guard","type":0,"sectionRef":"#","url":"lessons/scope-guard/","content":"Scope guard Conference","keywords":""},{"title":"Single Source of Truth","type":0,"sectionRef":"#","url":"lessons/single-source-of-truth/","content":"Single Source of Truth The Single Source of Truth principle is very simple : only store an information once ! And it stems from a very simple observation : if you store a value (or information that are deduced from that value) in several places, then they all need to be updated at the same time when you change that value. To do so you can try to write setter functions that will update the data in all the required places, but it is so easy to mess up, especially years in the future when someone else comes along and starts modifiyng the code. Basically it introduces oddities in the code that one must be aware of when working with it. This is why if often leads to bugs at some point ; and it also makes the code harder to reason about and maintain !","keywords":""},{"title":"Smart Pointers","type":0,"sectionRef":"#","url":"lessons/smart-pointers/","content":"Smart Pointers No naked new : this doesn't mean no dynamic allocations, it just means they should always be done through a smart pointer or a container. #include &lt;memory&gt; MyClass* x = new MyClass(); // BAD std::unique_ptr&lt;MyClass&gt; x = std::make_unique&lt;MyClass&gt;(); // GOOD std::shared_ptr&lt;MyClass&gt; x = std::make_shared&lt;MyClass&gt;(); // GOOD too, but less often what you need Copy","keywords":""},{"title":"Split problems in small pieces","type":0,"sectionRef":"#","url":"lessons/split-problems-in-small-pieces/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Split problems in small pieces","url":"lessons/split-problems-in-small-pieces/#brief","content":"If I were to sum up all the previous lessons, the most important takeaway would be: Write small things! Small functions, small classes. Create a lot of small abstractions that help you reason about your code. "},{"title":"Take small steps​","type":1,"pageTitle":"Split problems in small pieces","url":"lessons/split-problems-in-small-pieces/#take-small-steps","content":"When you are faced with a big programming task, if you don't know where to start try to split up the problem! Think about the smallest next step that you can take, that will produce a visible (testable) result and will get you ever so slightly closer to your final goal. Once split in small enough pieces, any problem should be manageable. I personally like to do the visual steps first, because then it is easier to debug / see your progress and it is more rewarding, you really feel like you are getting somewhere once something is displayed on the screen. "},{"title":"Create abstractions​","type":1,"pageTitle":"Split problems in small pieces","url":"lessons/split-problems-in-small-pieces/#create-abstractions","content":"Abstractions can make your code harder to understand at first glance, but they also make it easier to change (and therefore to manipulate). "},{"title":"Going further​","type":1,"pageTitle":"Split problems in small pieces","url":"lessons/split-problems-in-small-pieces/#going-further","content":"Going Further Tony Van Eerd, SOLID, Revisited (1h30) "},{"title":"State and Strategy","type":0,"sectionRef":"#","url":"lessons/state-and-strategy/","content":"State and Strategy Difference : State handles the changes itself, it is an implementation of a state machine. For Strategy, the decision of changing the strategy comes from the outside, it doesn't depend on what the current strategy is.","keywords":""},{"title":"Linter","type":0,"sectionRef":"#","url":"lessons/static-analysers/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Linter","url":"lessons/static-analysers/#brief","content":"There are a lot of bugs and bad coding habits that can be caught by tools. It can really help you a lot to improve the quality of your code! clang-tidy is a great one and I would recommend using it. "},{"title":"Installing​","type":1,"pageTitle":"Linter","url":"lessons/static-analysers/#installing","content":"You simply need to have clangd set up. To configure the behaviour of clang-tidy you need to have a .clang-tidy file at the root of your project. You can use mine as a starting point. Once that is done you should see warnings popping up inside your IDE:  Also note the &quot;Quick Fix... (Ctrl+;)&quot; option: sometimes clang-tidy is even capable of fixing the problem for you automatically! "},{"title":"Stack vs Heap","type":0,"sectionRef":"#","url":"lessons/stack-vs-heap/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#brief","content":"There are two kinds of memory where your variables can be created: the stack and the heap. Where you choose to create them has a lot of implications, but fear not: the choice is often very easy! "},{"title":"The Stack​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#the-stack","content":"This is the default. (And a good one at that). When you say for example int i = 3; you are creating a variable on the stack. "},{"title":"The Heap​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#the-heap","content":"When you say int* i = new int; you don't get an int, you get a pointer to an int. The actual int is created far far away, in the weird country of the heap. "},{"title":"Prefer the stack​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#prefer-the-stack","content":"You should almost always be using the stack! This is both simpler and more performant.  "},{"title":"Automatic cleanup​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#automatic-cleanup","content":"Variables that are on the stack are automatically destroyed when their scope ends: Stack { int i = 3; } // i is destroyed here, no memory can ever leak Copy Heap { int* i = new int; } // The pointer is destroyed here, but not the int that it was pointing to! We have a memory leak! // To fix that we need to do: { int* i = new int; delete i; } Copy "},{"title":"Performance​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#performance","content":"Allocating on the heap is much slower than allocating on the stack! Also, accessing variables on the heap might be slower because they are more likely to be spread out all over the memory and be in different cache lines. You can read more about that here. "},{"title":"When to use the heap​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#when-to-use-the-heap","content":"There are a few good reasons to use the heap. But you should always remember that since managing heap memory is complicated you should always use standard types that will do the heavy lifting for you. For example std::vector and std::unique_ptr use heap memory, but since they encapsulate it you don't have to worry about it. That's why we can have guidelines like never write new: if you need to have something allocated on the heap, use a std::unique_ptr or a std::shared_ptr that will handle the new and the delete for you. "},{"title":"For varying-size objects​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#for-varying-size-objects","content":"For the stack to be as efficient as it is, the size of all the variables must be known at compile-time. If for example you need a resizable array (std::vector), then you have no choice but to use the heap. std::string also allocates on the heap for the same reason. "},{"title":"For big objects​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#for-big-objects","content":"When you need a lot of memory to store something like an image or a 3D model, it might not fit on the stack. In such case you will need to use the heap (probably through a std::vector to store all the pixels or vertices). This also has the advantage that all of the data won't be copied when you are returning an image from a function: only the pointer is copied, since the pointed data that lives on the heap doesn't have to move and won't be destroyed when the scope of the function ends. "},{"title":"For polymorphism​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#for-polymorphism","content":"You can't know the size of a polymorphic class at compile time because some child classes could be bigger than the parent class. You therefore have to use the heap1. class ParentClass { int x; }; class ChildClass : public ParentClass { int y; }; ParentClass my_object = ChildClass{}; // Doesn't compile because you can't fit a ChildClass (two ints) into a ParentClass (one int). ParentClass* my_object = new ChildClass{}; // Works because the size of a pointer is always the same, no matter the size of the pointed object. Copy "},{"title":"Going further​","type":1,"pageTitle":"Stack vs Heap","url":"lessons/stack-vs-heap/#going-further","content":"Going Further The Cherno, Stack vs Heap Memory in C++ (20min) NB: actually you can use std::variant if you want polymorphic objects on the stack. std::variant is basically a better version of inheritance.↩ "},{"title":"Space out your code","type":0,"sectionRef":"#","url":"lessons/space-out-your-code/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Space out your code","url":"lessons/space-out-your-code/#brief","content":"One single statement doesn't have to be confined to a single line of code. If the line is getting long, you can always add a line break! I really like to add line breaks between each arguments of a function call, especially if they are important and I want to make them very easy to read: Ex 1 Good, you can quickly see each parameter and its value ctx.square(p6::Center{ctx.mouse()}, p6::Radius{0.3f}, p6::Rotation{0.011_turn}); Copy Not great, the last parameters are harder to read ctx.square(p6::Center{ctx.mouse()}, p6::Radius{0.3f}, p6::Rotation{0.011_turn}); Copy Ex 2 Good, this is readable _default_canvas.render_target().blit_to(glpp::RenderTarget::screen_framebuffer_id(), framebuffer_size(), glpp::Interpolation::NearestNeighbour); Copy Bad, the line is very long _default_canvas.render_target().blit_to(glpp::RenderTarget::screen_framebuffer_id(), framebuffer_size(), glpp::Interpolation::NearestNeighbour); Copy Ex 3 Good, ternary expressions don't have to be written in one single line const float aspect_ratio = _is_controlling_aspect_ratio ? _aspect_ratio.as_float() : img::SizeU::aspect_ratio(frame_size); Copy Bad, it is harder to see the two alternatives const float aspect_ratio = _is_controlling_aspect_ratio ? _aspect_ratio.as_float() : img::SizeU::aspect_ratio(frame_size); Copy Ex 4 Good, line breaks and alignment make the structure of the code very clear constexpr Color color_from_hexadecimal_code(unsigned int hex_code) { return Color(static_cast&lt;float&gt;((hex_code &amp; 0xFF0000u) &gt;&gt; 16) / 255.f, static_cast&lt;float&gt;((hex_code &amp; 0x00FF00u) &gt;&gt; 8) / 255.f, static_cast&lt;float&gt;((hex_code &amp; 0x0000FFu) &gt;&gt; 0) / 255.f); } Copy Ex 5 Great, for a constructor's initializer list line breaks are essential VideoExportProcess::VideoExportProcess(const VideoExportParams&amp; params, std::string_view folder_path, img::Size size) : _total_nb_of_frames_in_sequence{static_cast&lt;int&gt;(std::ceil((params.end - params.beginning) * params.fps))} , _max_nb_digits_of_frame_count{static_cast&lt;int&gt;(std::ceil(std::log10(_total_nb_of_frames_in_sequence)))} , _folder_path{folder_path} , _size{size} , _clock{params.fps, params.beginning} {} Copy Bad, I hate it so much VideoExportProcess::VideoExportProcess(const VideoExportParams&amp; params, std::string_view folder_path, img::Size size) : _total_nb_of_frames_in_sequence{static_cast&lt;int&gt;(std::ceil((params.end - params.beginning) * params.fps))}, _max_nb_digits_of_frame_count{static_cast&lt;int&gt;(std::ceil(std::log10(_total_nb_of_frames_in_sequence)))}, _folder_path{folder_path}, _size{size}, _clock{params.fps, params.beginning} {} Copy "},{"title":"Put your static objects in functions","type":0,"sectionRef":"#","url":"lessons/static-in-functions/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Put your static objects in functions","url":"lessons/static-in-functions/#brief","content":"There is a problem in C++ known as the Static Initialization Order Fiasco. It basically means that you should avoid having global static objects. An alternative to that is to put your objects as static local variables in functions, which makes it so that they won't be constructed until they are actually needed, which happens after the initialization of global static objects, thus avoiding some of the problems: // Bad, subject to the Static Initialization Order Fiasco std::string my_string{&quot;Hello&quot;}; Copy // Better std::string&amp; my_string() { static std::string instance{&quot;Hello&quot;}; return instance; } Copy "},{"title":"Static site generators","type":0,"sectionRef":"#","url":"lessons/static-site-generators/","content":"Static site generators","keywords":""},{"title":"static","type":0,"sectionRef":"#","url":"lessons/static/","content":"static ","keywords":""},{"title":"STL algorithms","type":0,"sectionRef":"#","url":"lessons/stl-algorithms/","content":"","keywords":""},{"title":"Find & find_if​","type":1,"pageTitle":"STL algorithms","url":"lessons/stl-algorithms/#find--find_if","content":""},{"title":"Filter​","type":1,"pageTitle":"STL algorithms","url":"lessons/stl-algorithms/#filter","content":""},{"title":"Map​","type":1,"pageTitle":"STL algorithms","url":"lessons/stl-algorithms/#map","content":""},{"title":"Reduce​","type":1,"pageTitle":"STL algorithms","url":"lessons/stl-algorithms/#reduce","content":""},{"title":"std::function","type":0,"sectionRef":"#","url":"lessons/std-function/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"std::function","url":"lessons/std-function/#brief","content":"std::function is a simple yet powerful type. It can basically store any function: this allows you to pass functions as parameters to other functions, or to store a function for later use. #include &lt;functional&gt; std::vector&lt;std::function&lt;void()&gt;&gt; callbacks; // A list of functions that we will call when some special event happens. Copy A std::function can be a lambda: callbacks.push_back( []() { std::cout &lt;&lt; &quot;Lambda\\n&quot;; } ); Copy or a function pointer: void my_callback() { std::cout &lt;&lt; &quot;Function pointer\\n&quot;; } callbacks.push_back( &amp;my_callback ); Copy or a function object: struct MyCallback { void operator()() const { std::cout &lt;&lt; &quot;Function object\\n&quot;; } }; callbacks.push_back( MyCallback{} ); Copy We would than use our callbacks like so: for (const auto&amp; callback : callbacks) { callback(); } Copy "},{"title":"Signature​","type":1,"pageTitle":"std::function","url":"lessons/std-function/#signature","content":"std::function stores functions with a given signature. For example std::function&lt;int(float)&gt; is a function that takes a float and returns an int. "},{"title":"std::string and std::string_view","type":0,"sectionRef":"#","url":"lessons/string-and-string-view/","content":"","keywords":""},{"title":"string​","type":1,"pageTitle":"std::string and std::string_view","url":"lessons/string-and-string-view/#string","content":""},{"title":"string_view​","type":1,"pageTitle":"std::string and std::string_view","url":"lessons/string-and-string-view/#string_view","content":"It is a new type from C++17. It is a non-owning reference to either a const char* or a std::string. It has many advantages: providing the same API as std::string for const char* without having to pay the cost of constructing a std::string, working with const char* and std::string as if they were the same type, etc. Just remember that it is non-owning, like a reference: it is great for passing parameters around, but if you need to store it as a long-lasting variable you probably still need to use a std::string. "},{"title":"Strong Types","type":0,"sectionRef":"#","url":"lessons/strong-types/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Strong Types","url":"lessons/strong-types/#brief","content":"Strong typing is when you create a type just to wrap an int, so that you can give that int a name, invariants, and so on. It helps you express your intent more clearly and makes your APIs harder to misuse. They are amazing and definitely worth the extra little time needed to write them down! tip Strong typedefs (as well as a few other amazing features) are available in the great type_safe library. You should consider using it if you want to use strong types. Read this article about the strong typedefs available in the library. "},{"title":"Details​","type":1,"pageTitle":"Strong Types","url":"lessons/strong-types/#details","content":"Read this great article about strong types. And then look at this great example of how using strong types can prevent nasty bugs. Once you are done with these, I want to give an example of my own: Consider a 2D position (a.k.a a point) and a 2D displacement (a.k.a. a vector). They can both be represented with two numbers x and y even though they are very different concepts! The fact that they are two different things means that we can't necessarily do the same operations on them! Strong typing can protect us from accidently doing that. For example, adding two displacements d1 and d2 makes total sense: it simply yields another displacement that corresponds to moving by d1 and then by d2 :  Adding a displacement to a position is perfectly reasonable too: it moves the position:  But adding two positions doesn't make sense at all!  Even though it would be easy to add the representation of two positions, we want to prevent that because it would almost certainly be a logic error. Recap Strong types help you give a more concrete representation to concepts, physical units, coordinate spaces, and much more! They prevent logic errors and make APIs harder to misuse. "},{"title":"Going further​","type":1,"pageTitle":"Strong Types","url":"lessons/strong-types/#going-further","content":"Going Further Mateusz Pusz, A Physical Units Library For the Next C++ (1h) Strong types for physical units Robert Ramey, C++, Abstract Algebra and Practical Applications (1h) Strong types to enforce invariants and model Abstract Algebra concepts "},{"title":"Structured bindings","type":0,"sectionRef":"#","url":"lessons/structured-bindings/","content":"Structured bindings","keywords":""},{"title":"Templates","type":0,"sectionRef":"#","url":"lessons/templates/","content":"Templates","keywords":""},{"title":"Trailing return type","type":0,"sectionRef":"#","url":"lessons/trailing-return-type/","content":"Trailing return type","keywords":""},{"title":"Type erasure","type":0,"sectionRef":"#","url":"lessons/type-erasure/","content":"Type erasure https://youtu.be/jKt6A3wnDyI","keywords":""},{"title":"Testing","type":0,"sectionRef":"#","url":"lessons/testing/","content":"","keywords":""},{"title":"Unit Tests​","type":1,"pageTitle":"Testing","url":"lessons/testing/#unit-tests","content":"For example I wrote tests for the code that computes your grades: TODO PUT A LINK "},{"title":"UnitTesting libraries​","type":1,"pageTitle":"Testing","url":"lessons/testing/#unittesting-libraries","content":"There a few out there. I personaly use and recommend doctest. Other popular libraries include GoogleTest and Catch2. "},{"title":"Test-Driven Development (TDD)​","type":1,"pageTitle":"Testing","url":"lessons/testing/#test-driven-development-tdd","content":"http://blog.wingman-sw.com/tdd-guided-by-zombies "},{"title":"Going further​","type":1,"pageTitle":"Testing","url":"lessons/testing/#going-further","content":"Going further Phil Nash, Test Driven C++ (1h) About TDD "},{"title":"Variables","type":0,"sectionRef":"#","url":"lessons/variables/","content":"Variables","keywords":""},{"title":"Use libraries","type":0,"sectionRef":"#","url":"lessons/use-libraries/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Use libraries","url":"lessons/use-libraries/#brief","content":"In the real world no one writes everything from scratch. If you need a feature, most likely other people have had the same need before you, and chances are they made a library out of it! If you need a big thing and are almost ready to spend the next three months implementing it, it might be wise to first have a look on the internet and see if some solution already exists. Most often you will discover that there is even several of them and you will have the leisure to pick and chose the one that seems to best suit your needs. "},{"title":"How to​","type":1,"pageTitle":"Use libraries","url":"lessons/use-libraries/#how-to","content":""},{"title":"Build from source​","type":1,"pageTitle":"Use libraries","url":"lessons/use-libraries/#build-from-source","content":"Building from source means that: anyone simply has to clone your project and is guaranteed to have all the dependenciesyou never have any version conflictyou can tweak the libraries if you need to (and if their license allows so)you have quick access to the source code to read it and your IDE can jump to it To add a library to your project you can simply download the folder and copy it into your project, but a better practice is to use a Git submodule. "},{"title":"Add them to your project with CMake​","type":1,"pageTitle":"Use libraries","url":"lessons/use-libraries/#add-them-to-your-project-with-cmake","content":"If the library provides good CMake support, all you should have to do is: add_subdirectory(libname) target_link_libraries(${PROJECT_NAME} PRIVATE libname) Copy If not, then you will have to define the target and its requirements yourself. For that, check out the lesson on CMake for library authors. "},{"title":"Read the documentation​","type":1,"pageTitle":"Use libraries","url":"lessons/use-libraries/#read-the-documentation","content":"Read the doc! Really! Or at least all the tutorial and introduction parts! Whenever I finally take the time to sit down and go through the documentation of a library I use, I always end up cursing myself for not doing it earlier because I learn so much while reading it and I realize it would have saved me a lot of debugging time if I had read it before trying to blindly use the library! Plus you will discover amazing features that you were not even aware of! tip Take the time and Read the Fucking Manual. Programing is a slow and patient process. You will save time later down the road if you take the time to do things properly from the get go.  "},{"title":"std::variant","type":0,"sectionRef":"#","url":"lessons/variant/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"std::variant","url":"lessons/variant/#brief","content":"std::variant&lt;int, float&gt; my_variant; is a variable that can hold either an int or a float, and the actual type it holds can change at runtime. Using std::variant with int and float is not all that useful, but it starts to get very interesting when we use variant to represent the different states that we could be in, or to achieve polymorphism for example: std::variant&lt;TrackballCamera, FreeflyCamera&gt;.   An example of using variant. Another example of using variant. std::variant is a very good alternative to enums because – on top of beeing a list of possible states – it can contain data. "},{"title":"Going further​","type":1,"pageTitle":"std::variant","url":"lessons/variant/#going-further","content":"Going Further Klaus Iglberger, Breaking Dependencies - The Visitor Design Pattern in Cpp (1h) Ben Deane, Using Types Effectively (1h) Mateusz Pusz, Effective replacement of dynamic polymorphism with std::variant (30min) "},{"title":"wasm and electron","type":0,"sectionRef":"#","url":"lessons/wasm-and-electron/","content":"wasm and electron","keywords":""},{"title":"std::vector","type":0,"sectionRef":"#","url":"lessons/vector/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"std::vector","url":"lessons/vector/#brief","content":"This is by far the best container! It can do everything and is also the most performant in almost all situations. If you use another container than std::vector you must have a very strong reason to do so! Most notably, even if std::list has a better algorithmic complexity for some operations, in most cases std::vector will still be faster in practice because it has better cache coherency (the data is grouped together in memory, which makes it much faster to access).    "},{"title":"Initializer-list syntax​","type":1,"pageTitle":"std::vector","url":"lessons/vector/#initializer-list-syntax","content":"Instead of std::vector&lt;int&gt; v; v.push_back(1); v.push_back(7); v.push_back(4); v.push_back(12); Copy you can write std::vector&lt;int&gt; v{1, 7, 4, 12}; Copy These are totally equivalent. And by the way this syntax works for all the containers, not only std::vector. "},{"title":"Watch conferences","type":0,"sectionRef":"#","url":"lessons/watch-conferences/","content":"Watch conferences This is the best away to improve once you have acquired a solid basis through classes and projects. The first few conferences you will watch will be hard and you will be lost because you won't know many of the topics that the speaker will refer to. Don't worry and keep going, you will naturally learn those topics one by one as you watch more and more conferences. And not understanding a topic that the speaker refers to should not prevent you from understanding the general idea of the conference. In the resources you will find a list of amazing conferences, sorted by quality and ease of access; so I recommend to start with these, in the order they are listed in.","keywords":""},{"title":"Write debug tools","type":0,"sectionRef":"#","url":"lessons/write-debug-tools/","content":"Write debug tools When you write test code to help you develop a feature, don't throw that code away once you are done with your feature! This code will be helpful again one day, when you need to debug something or change the feature. Put an on/off option onto it, hide it behind a #if DEBUG, but put an option in your UI to re-enable it so that it is always close at hand when you will need it. This can be for example a view in your UI that shows you the state of some system.","keywords":""},{"title":"Use structs to group data","type":0,"sectionRef":"#","url":"lessons/use-structs-to-group-data/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Use structs to group data","url":"lessons/use-structs-to-group-data/#brief","content":"Structs allow you to group data together. When there are no invariants to enforce, using a struct and having all your data public is better that using a class. "},{"title":"When to prefer a struct to a class​","type":1,"pageTitle":"Use structs to group data","url":"lessons/use-structs-to-group-data/#when-to-prefer-a-struct-to-a-class","content":"First, what is the difference between a class and a struct?1 A class can have private members, it can have methods attached to it2, and it can use inheritance. Inheritance is not always a good option so we are not going to consider it here (see Composition over Inheritance). We are then left with methods and private attributes, which actually both serve the same goal: enforcing invariants. tip Classes have one goal: enforcing invariants. info An invariant is a property that is always true for your class. For example, a PointInsideUnitDisk class might store its state as an x and y values, and have the invariant that the length of the (x, y) vector is always less than 1. This invariant needs to be enforced by all the methods, e.g. by deciding what happens when we call set_x(): do we just set the x and throw an exception if the length of (x, y) is now greater than 1? Do we set the x and then normalize the (x, y) vector if its length would otherwise become greater than 1? Or do we not expose a set_x() method at all? All of these answers can be valid; it just depends on the context and on how you plan to use your PointInsideUnitDisk class. On the other hand a Point2D &quot;class&quot; might also store its state as an x and y values, but doesn't have any invariant to enforce because any values are valid for x and y. In that case Point2D might be better represented as a struct rather than a class. If you don't have any invariants, you will end up with a class that only has getters and setters that do nothing special: this is basically a struct with an uglier syntax. You could also have member functions, but if your member variables all have getters and setters then you could always replace these member functions with free functions, which is a better practice anyways (see Prefer free functions). tip Prefer using a struct over a class if you have no invariants to enforce (see the C++ Core Guidelines). "},{"title":"Examples​","type":1,"pageTitle":"Use structs to group data","url":"lessons/use-structs-to-group-data/#examples","content":"Often, if you notice that you are passing the same group of parameters to a few functions, it is a great oportunity to create a struct: it will simplify parameter passing, make it easier to add a parameter to the group later, and it adds an abstraction to your code that might help you reason about it and that you might reuse later. For example, if many functions take an x and a y you might refactor this into a Point or Point2D struct. On the other hand if you need a point that is restricted to, say, a disk on the plane, then you will need a class to enforce that invariant. Moreover, if this group of parameters is supposed to have a default value, then you can encode it in the struct instead of duplicating it all over the place in all the functions that take those parameters: // Bad, we are duplicating our default values class Texture { // . . . void resize (ImageSize size, InternalFormat internal_format = InternalFormat::RGBA, Channels channels = Channels::RGBA, TexelDataType texel_data_type = TexelDataType::UnsignedByte); void upload_data(ImageSize size, const void* data, InternalFormat internal_format = InternalFormat::RGBA, Channels channels = Channels::RGBA, TexelDataType texel_data_type = TexelDataType::UnsignedByte); }; Copy // Good, we have removed some duplications and introduced a useful abstraction struct TextureLayout { InternalFormat internal_format = InternalFormat::RGBA; Channels channels = Channels::RGBA; TexelDataType texel_data_type = TexelDataType::UnsignedByte; }; class Texture { // . . . void resize(ImageSize size, TextureLayout layout = {}); void upload_data(ImageSize size, const void* data, TextureLayout layout = {}); }; Copy "},{"title":"Designated initializers​","type":1,"pageTitle":"Use structs to group data","url":"lessons/use-structs-to-group-data/#designated-initializers","content":"In C++20 structs have become even more amazing thanks to designated initializers: Given this struct struct WindowConfig { const char* title = &quot;Hello World&quot;; // The title that will be displayed in the title bar of the window int initial_width = 1280; // Initial width of the window int initial_height = 720; // Initial height of the window bool cap_framerate_on_startup_if = true; // Whether the framerate should be capped or not (this can later be changed at runtime through window.cap_framerate_if()) bool maximize_on_startup_if = is_building_as(BuildMode::Release); // Whether the window will be maximized when the application starts. bool hide_on_startup_if = false; // Whether the window will be hidden when the application starts. }; Copy you can now initialize it by naming its members: const auto window_config = WindowConfig{ .title = &quot;Hello C++&quot;, .initial_width = 500, .initial_height = 500, .maximize_on_startup_if = true, }; Copy Which is much more readable than const auto window_config = WindowConfig{&quot;Hello C++&quot;, 500, 500, true, true, false}; Copy And note that you can skip some members (like cap_framerate_on_startup_if in this example). They will be initialized with their default value. This makes structs a viable option to emulate named parameters in C++. I am talking about the semantic differences here, because in C++ a class and a struct can do exactly the same things. The only difference is that by default if you don't use an access specifier everything is private in a class and public in a struct.↩Although I am not opposed to having methods in a struct.↩ "},{"title":"Write libraries","type":0,"sectionRef":"#","url":"lessons/write-libraries/","content":"Write libraries Even if it's only for your personal use, it will help you a lot with code reuse across projects and also inside one project. And also it will force you to make your code a little more generic, which most of the time will improve it at the same time. Moreover, it will make sure that the code is decoupled from the rest of your application. So : as soon as you are write some bit of code that is fairly generic, consider turning it into a library. For CMake refer back to here. I would only advice to do it once you are experrienced though. Because it takes wisdow to know how generic your needs to be: dpon't iver do it, but don't under do it either.","keywords":""},{"title":"Single Responsibility","type":0,"sectionRef":"#","url":"slides/","content":"","keywords":""},{"title":"Slides​","type":1,"pageTitle":"Single Responsibility","url":"slides/#slides","content":"NB: il y a des commentaires sur certaines slides, pensez à les lire 😉 https://docs.google.com/presentation/d/18aRPUkXi30gHWpvKvwurxDO-Nj5GkceuJKqFGsAi-10/edit?usp=sharing "},{"title":"Pour aller plus loin​","type":1,"pageTitle":"Single Responsibility","url":"slides/#pour-aller-plus-loin","content":"Going Further CodeAesthetic, Why You Shouldn't Nest Your Code (8min) Tony Van Eerd, SOLID, Revisited (1h30) "},{"title":"Early return","type":0,"sectionRef":"#","url":"slides/early-return/","content":"","keywords":""},{"title":"Slides​","type":1,"pageTitle":"Early return","url":"slides/early-return/#slides","content":"NB: il y a des commentaires sur certaines slides, pensez à les lire 😉 https://docs.google.com/presentation/d/11Ut1hJI60fAZZW_nsgEjbjJcKWLgWJyZY-UhMuwOGAk/edit?usp=sharing "},{"title":"Enum | Single Source of Truth | Abstract away implementation details","type":0,"sectionRef":"#","url":"slides/enum/","content":"","keywords":""},{"title":"Slides​","type":1,"pageTitle":"Enum | Single Source of Truth | Abstract away implementation details","url":"slides/enum/#slides","content":"NB: il y a des commentaires sur certaines slides, pensez à les lire 😉 https://docs.google.com/presentation/d/1ewAS0SjWDKRyf75cMOWeHOKCbv0TjIusaqf6VgfH04E/edit?usp=sharing "},{"title":"Move constructor | Rule of Zero","type":0,"sectionRef":"#","url":"slides/move-rule_of_zero/","content":"","keywords":""},{"title":"Slides​","type":1,"pageTitle":"Move constructor | Rule of Zero","url":"slides/move-rule_of_zero/#slides","content":"NB: il y a des commentaires sur certaines slides, pensez à les lire 😉 https://docs.google.com/presentation/d/1ErOHhpi2ifwNKjsoxZ5mvJWezX1O0GhOrMy30c_Iz3o/edit?usp=sharing Pour aller plus loin Move constructor Rule of Zero / Rule of Five "},{"title":"std::optional | Pointer vs Reference","type":0,"sectionRef":"#","url":"slides/optional pointer reference/","content":"","keywords":""},{"title":"Slides​","type":1,"pageTitle":"std::optional | Pointer vs Reference","url":"slides/optional pointer reference/#slides","content":"NB: il y a des commentaires sur certaines slides, pensez à les lire 😉 https://docs.google.com/presentation/d/16h7nbTQcNKhR-6Ny--40mbhqOSFCqzUOMrPsW89sizs/edit?usp=sharing "},{"title":"std::function | Minimize dependencies","type":0,"sectionRef":"#","url":"slides/std_function minimize dependencies/","content":"","keywords":""},{"title":"Slides​","type":1,"pageTitle":"std::function | Minimize dependencies","url":"slides/std_function minimize dependencies/#slides","content":"NB: il y a des commentaires sur certaines slides, pensez à les lire 😉 https://docs.google.com/presentation/d/1gRtYGoLMdudeJMk3vqttePEouwAEFb8BFKX_KojMBTM/edit?usp=sharing "},{"title":"Struct vs Class","type":0,"sectionRef":"#","url":"slides/Struct vs Class/","content":"","keywords":""},{"title":"Slides​","type":1,"pageTitle":"Struct vs Class","url":"slides/Struct vs Class/#slides","content":"NB: il y a des commentaires sur certaines slides, pensez à les lire 😉 https://docs.google.com/presentation/d/1BUwMrBheIKS7ALjnJHgjmwTaC8qkRPkj1z-84H0ZjZc/edit?usp=sharing "},{"title":"Jeu d'échec","type":0,"sectionRef":"#","url":"sujet/","content":"","keywords":""},{"title":"Sujet​","type":1,"pageTitle":"Jeu d'échec","url":"sujet/#sujet","content":"Dans ce projet, vous allez coder un jeu d'échec. Si vous ne connaissez pas les règles voici un petit tuto. Notez que nous n'allons pas implémenter certaines règles un peu trop compliquées, vous trouverez plus bas le détail de ce que vous devez implémenter. De plus, il y aura quelques règles supplémentaires dans notre jeu d'échecs : des évènements aléatoires viendront perturber la partie. Je vous renvoie au sujet de maths que vous donnera Mr. Martinez pour plus d'infos sur ces évènements aléatoires que vous devrez implémenter. "},{"title":"Infos​","type":1,"pageTitle":"Jeu d'échec","url":"sujet/#infos","content":"Ce projet sera commun avec les cours de Synthèse d'Image et de Mathématiques. Les profs des matières respectives vous donneront leurs parties du sujet.Ce projet se fera par groupes de 2 (et exceptionnellement il peut y avoir un groupe de 3 ou de 1)Pour ce cours de C++ j'évaluerai l'entièreté du code du projet, y compris celui de synthèse d'image et de maths. De plus, je n'évalue pas uniquement le nombre de features implémentées, mais aussi (et surtout) la qualité / clarté du code, et le respect des conseils que je vous donnerai dans les différents points de cours tout au long du semestre. "},{"title":"Deadline​","type":1,"pageTitle":"Jeu d'échec","url":"sujet/#deadline","content":"Le projet sera à rendre jeudi 10 avril à 23h59, la veille de la soutenance. "},{"title":"Pour bien démarrer​","type":1,"pageTitle":"Jeu d'échec","url":"sujet/#pour-bien-démarrer","content":"Je vous recommande très fortement de partir de ce template de projet. Il inclut déjà la librairie Dear ImGui dont vous aurez besoin (cf. les consignes ci-après). Il contient aussi des fichiers .clang-format et .clang-tidy (que vous pouvez modifier si vous le souhaitez). "},{"title":"Consignes​","type":1,"pageTitle":"Jeu d'échec","url":"sujet/#consignes","content":" Le jeu se jouera via une GUI codée avec la librairie Dear ImGui. Cette librairie vous permettra facilement de placer des boutons à l'écran, qui représenteront les cases du plateau, et sur lesquels on pourra cliquer pour sélectionner les pièces et les déplacer. Vous trouverez dans le template de projet que je vous ai fourni quelques exemples sur l'utilisation de la librairie. Puis vous ferez une visualisation en 3D du plateau et des pièces (cf. le sujet de synthèse d'image), mais même après ça vous garderez la GUI pour jouer les mouvements des pièces, et le monde 3D reflétera les changements. (En bonus, vous pouvez faire du picking en 3D pour cliquer directement dans le monde 3D pour sélectionner les pièces, mais c'est du bonus) "},{"title":"Features à implémenter​","type":1,"pageTitle":"Jeu d'échec","url":"sujet/#features-à-implémenter","content":" Les pièces sont représentées par un bouton de leur couleur (blanc ou noir), avec une lettre les représentant (P pour Pion, etc.) Les cases vides sont soit claires soit sombres, en fonction d'un pattern d'échiquier. La case en bas à gauche est une case sombre. Le plateau commence avec les pièces disposées ainsi, les blancs toujours en bas : Chaque joueur joue tour à tour. On ne peut pas déplacer deux pièces d'une même couleur d'affilée. Ce sont toujours les blancs qui commencent la partie Quand on clique sur une pièce elle devient sélectionnée, puis quand on clique sur une case la pièce sélectionnée se déplace sur cette case (si le coup est valide). On peut désélectionner la pièce avec un clic-droit (if (ImGui::IsMouseClicked( ImGuiMouseButton_Right ))). Quand une pièce est sélectionnée, indiquer toutes les cases sur lesquelles elle peut se déplacer Victoire quand on mange le roi adverse (la détection automatique des échecs, et échec et mat, n'est pas demandée) La tour se déplace en ligne droite, d'autant de cases qu'elle veut tant qu'elle n'est pas bloquée par une autre pièce Le fou se déplace en diagonale, d'autant de cases qu'il veut tant qu'il n'est pas bloqué par une autre pièce Le cavalier se déplace en L La dame peut se déplacer dans toutes les directions (ligne droite ou diagonale), tant qu'elle n'est pas bloquée par une autre pièce Le roi peut se déplacer d'une case dans toutes les directions Le pion peut avancer d'une case, et peut manger les pièces qui sont une case en diagonale devant lui Si il n'a pas encore bougé, un pion peut avancer de deux cases d'un coup Quand un pion arrive sur la dernière ligne du plateau, il est transformé en une autre pièce (c'est le joueur qui choisit : une dame, une tour, un fou ou un cavalier). Pour que le joueur choisisse, vous pouvez par exemple faire apparaître une fenêtre modale avec ImGui. &quot;En passant&quot;: si un pion avance de deux cases, et arrive à côté d'un pion adverse, le pion adverse peut manger le pion en avançant derrière lui. NB: ce doit être fait le tour immédiatement après le déplacement du pion, si l'adversaire décide de jouer autre chose, il ne peut pas manger &quot;en passant&quot; plus tard. "},{"title":"Règles que vous n'avez pas besoin d'implémenter​","type":1,"pageTitle":"Jeu d'échec","url":"sujet/#règles-que-vous-navez-pas-besoin-dimplémenter","content":"RoquerLes diverses conditions qui causent un match nulVictoire quand on met le roi adverse échec et matQuand le roi est en échec, les seuls coups autorisés sont des coups qui font que le roi n'est plus en échec "},{"title":"Pour aller plus loin​","type":1,"pageTitle":"Jeu d'échec","url":"sujet/#pour-aller-plus-loin","content":"Voici des consignes optionnelles que vous pouvez suivre afin d'étoffer votre projet. (Vous pouvez aussi rajouter vos propres idées). Ceci dit, avant de vous lancer dans ces nouvelles fonctionnalités, n'oubliez pas que le plus important dans l'évaluation reste la qualité du code, donc ne commencez pas à rajouter des choses si vous n'êtes pas confiant.es que ce que vous avez déjà est solide. Coder de nouvelles pièces, avec de nouveaux patterns de déplacementQuand on déplace une pièce, au lieu qu'elle se téléporte instantanément à sa nouvelle position, faire une animation où elle se déplace progressivement vers sa nouvelle position (dans le monde 3D)Pouvoir sauvegarder et charger des parties, avec la notation FENPouvoir choisir la taille du plateau (par exemple jouer sur un 6x6 ou un 13x13)Avoir un historique de tous les coups joués et pouvoir revenir en arrièreImplémenter les règles qui n'étaient pas demandéesCoder une IA "},{"title":"Write small functions","type":0,"sectionRef":"#","url":"lessons/write-small-functions/","content":"","keywords":""},{"title":"Brief​","type":1,"pageTitle":"Write small functions","url":"lessons/write-small-functions/#brief","content":"Small functions: are way easier to read and reason about. describe your intent, and allow you to change the implementation behind it easily. facilitate future refactorings because the logic is already split into atomic parts. are easier to search for in the codebase. force you to give meaning by giving names, not only to the action (the function) but also to its parameters; for example: void do_something(Thread&amp; thread, bool is_main_thread) { /*...*/ } for (size_t i = 0; i &lt; threads.size(); ++i) { do_something(threads[i], i == 0); // Thanks to the parameter name we know that `i == 0` actually checks to see if the current thread is the main thread } Copy Important: Here is what the Core Guidelines have to say about small functions. "},{"title":"Details​","type":1,"pageTitle":"Write small functions","url":"lessons/write-small-functions/#details","content":"I used to write long functions like this one, using comments to indicate the different parts of the function. I did not want to write intermediate functions because it felt silly to me to create functions that I would only use once. void View::imgui_window(ImTextureID image_texture_id, ImageSize image_size, bool need_to_fit) { if (_is_open) { ImGui::Begin(_name.c_str(), &amp;_is_open, ImGuiWindowFlags_NoScrollbar); // Store window size const auto size = ImGui::GetContentRegionAvail(); if (size.x &gt;= 1.f &amp;&amp; size.y &gt;= 1.f) { _size.emplace( static_cast&lt;ImageSize::DataType&gt;(size.x), static_cast&lt;ImageSize::DataType&gt;(size.y)); } else { _size.reset(); } // Store window position _position = ImGui::GetCursorScreenPos(); if (_size.has_value()) { // Display the image const auto fitted_image_size = need_to_fit ? ImageSizeU::fit_into(*_size, image_size) : static_cast&lt;ImageSizeT&lt;float&gt;&gt;(*_size); ImGuiExtras::image_centered(image_texture_id, {fitted_image_size.width(), fitted_image_size.height()}); _is_hovered = ImGui::IsItemHovered(); } else { _is_hovered = false; } ImGui::End(); } else { _size.reset(); _is_hovered = false; } } Copy But I had to admit that I was having trouble reading those long functions, and that maybe everyone else was right. The same code as above would look like this once split into more atomic parts: void View::imgui_window(ImTextureID image_texture_id, ImageSize image_size, bool need_to_fit) { if (_is_open) { ImGui::Begin(_name.c_str(), &amp;_is_open, ImGuiWindowFlags_NoScrollbar); store_window_size(); store_window_position(); display_image(image_texture_id, image_size, need_to_fit); ImGui::End(); } else { _size.reset(); _is_hovered = false; } } void View::store_window_size() { const auto size = ImGui::GetContentRegionAvail(); if (size.x &gt;= 1.f &amp;&amp; size.y &gt;= 1.f) { _size.emplace( static_cast&lt;ImageSize::DataType&gt;(size.x), static_cast&lt;ImageSize::DataType&gt;(size.y)); } else { _size.reset(); } } void View::store_window_position() { _position = ImGui::GetCursorScreenPos(); } void View::display_image(ImTextureID image_texture_id, ImageSize image_size, bool need_to_fit) { if (_size.has_value()) { const auto fitted_image_size = need_to_fit ? ImageSizeU::fit_into(*_size, image_size) : static_cast&lt;ImageSizeT&lt;float&gt;&gt;(*_size); ImGuiExtras::image_centered(image_texture_id, {fitted_image_size.width(), fitted_image_size.height()}); _is_hovered = ImGui::IsItemHovered(); } else { _is_hovered = false; } } Copy "},{"title":"Going further​","type":1,"pageTitle":"Write small functions","url":"lessons/write-small-functions/#going-further","content":"Going Further CodeAesthetic, Why You Shouldn't Nest Your Code (8min) Tony Van Eerd, SOLID, Revisited (1h30) "}]